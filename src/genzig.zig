const builtin = @import("builtin");
const std = @import("std");
const ArrayList = std.ArrayList;
const StringHashMap = std.StringHashMap;
const StringPool = @import("StringPool.zig");

const cameltosnake = @import("cameltosnake.zig");

const common = @import("common.zig");
const metadata = @import("metadata.zig");
const extra = @import("extra.zig");
const jsonextra = @import("jsonextra.zig");
const pass1data = @import("pass1data.zig");
const oom = common.oom;
const fatal = common.fatal;
const jsonPanic = common.jsonPanic;
const jsonPanicMsg = common.jsonPanicMsg;
const jsonEnforce = common.jsonEnforce;
const jsonEnforceMsg = common.jsonEnforceMsg;
const fmtJson = common.fmtJson;

const BufferedWriter = std.io.BufferedWriter(std.mem.page_size, std.fs.File.Writer);

var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
const allocator = arena.allocator();

const autogen_header = "//! NOTE: this file is autogenerated, DO NOT MODIFY\n";

var global_symbol_pool = StringPool.init(allocator);

var global_symbol_none: StringPool.Val = undefined;
var global_symbol_None: StringPool.Val = undefined;

var global_pass1: pass1data.Root = undefined;
var global_extra: extra.Root = undefined;
var global_com_overloads: StringPool.HashMapUnmanaged(ComTypeMap) = .{};
const MissingOverload = struct {
    api: StringPool.Val,
    com_type: []const u8,
    method: []const u8,
    method_index: u16,
};
var global_missing_com_overloads: std.ArrayListUnmanaged(MissingOverload) = .{};

fn zigTypeFromIntegerBase(maybe_explicit_base: ?metadata.EnumIntegerBase) []const u8 {
    return if (maybe_explicit_base) |base| switch (base) {
        .Byte => "u8",
        .SByte => "i8",
        .UInt16 => "u16",
        .UInt32 => "u32",
        .Int32 => "i32",
        .UInt64 => "u64",
    } else "i32";
}
fn zigTypeFromValueType(t: metadata.ValueType) []const u8 {
    return switch (t) {
        .Byte => return "u8",
        .UInt16 => return "u16",
        .Int32 => return "i32",
        .UInt32 => return "u32",
        .Int64 => return "i64",
        .UInt64 => return "u64",
        .Single => return "f32",
        .Double => return "f64",
        .String => return "[]const u8",
        .PropertyKey => @panic("cannot call valueTypeToZigType for ValueType.PropertyKey"),
    };
}

const Pass1TypeCategory = enum { default, ptr, com };
pub fn getPass1TypeCategory(kind: pass1data.TypeKind) Pass1TypeCategory {
    return switch (kind) {
        .Integral => .default,
        .Enum => .default,
        .Struct => .default,
        .Union => .default,
        .Pointer => .ptr,
        .FunctionPointer => .ptr,
        .Com => .com,
    };
}

const Module = struct {
    optional_parent: ?*Module,
    name: StringPool.Val,
    zig_basename: []const u8,
    children: StringPool.HashMap(*Module),
    file: ?SdkFile,
    pub fn alloc(optional_parent: ?*Module, name: StringPool.Val) !*Module {
        const module = try allocator.create(Module);
        module.* = Module{
            .optional_parent = optional_parent,
            .name = name,
            .zig_basename = try std.mem.concat(allocator, u8, &[_][]const u8{ name.slice, ".zig" }),
            .children = StringPool.HashMap(*Module).init(allocator),
            .file = null,
        };
        return module;
    }
};

const import_prefix_table = &[_][]const u8{
    "",
    "../",
    "../../",
    "../../../",
    "../../../../",
};

const ApiImport = struct {
    arches: metadata.Architectures,
    api: StringPool.Val,
};

fn StringPoolArrayHashMap(comptime T: type) type {
    return std.ArrayHashMap(StringPool.Val, T, StringPool.ArrayHashContext, false);
}

const SdkFile = struct {
    json_basename: []const u8,
    json_name: StringPool.Val,
    zig_name: []const u8,
    depth: u2,
    const_exports: ArrayList(StringPool.Val),
    uses_guid: bool,
    top_level_api_imports: StringPool.HashMap(ApiImport),
    // maintin insertion order so they appear in the same order in everything.zig
    type_exports: StringPoolArrayHashMap(void),
    // maintin insertion order so they appear in the same order in everything.zig
    func_exports: StringPoolArrayHashMap(void),
    // this field is only needed to workaround: https://github.com/ziglang/zig/issues/4476
    tmp_func_ptr_workaround_list: ArrayList(StringPool.Val),
    method_conflict_map: std.StaticStringMap(void),
    param_conflict_map: std.StaticStringMap(void),
    extra_funcs: extra.Functions,
    extra_funcs_applied: StringPool.HashMap(void),
    extra_consts: extra.Constants,
    extra_consts_applied: StringPool.HashMap(void),
    com_type_overloads: ?std.StringHashMapUnmanaged(ComMethodMap),

    pub fn getWin32DirImportPrefix(self: SdkFile) []const u8 {
        return import_prefix_table[self.depth];
    }
    pub fn getSrcDirImportPrefix(self: SdkFile) []const u8 {
        return import_prefix_table[self.depth + 1];
    }

    pub fn addApiImport(
        self: *SdkFile,
        arches: metadata.Architectures,
        name: []const u8,
        api: StringPool.Val,
        parents: []const []const u8,
    ) !void {
        if (self.json_name.eql(api))
            return;

        const top_level_symbol = try global_symbol_pool.add(if (parents.len == 0) name else parents[0]);
        if (self.top_level_api_imports.getPtr(top_level_symbol)) |import| {
            jsonEnforceMsg(
                api.eql(import.api),
                "symbol conflict '{s}', api mismatch '{s}' and '{s}'",
                .{ name, api, import.api },
            );
            import.arches = import.arches.unionWith(arches);
        } else {
            try self.top_level_api_imports.put(top_level_symbol, .{ .arches = arches, .api = api });
        }
    }
};

const Times = struct {
    parse_time_millis: i64 = 0,
    read_time_millis: i64 = 0,
    generate_time_millis: i64 = 0,
};
var global_times = Times{};

pub fn main() !u8 {
    const main_start_millis = std.time.milliTimestamp();
    var print_time_summary = false;
    defer {
        if (print_time_summary) {
            var total_millis = std.time.milliTimestamp() - main_start_millis;
            if (total_millis == 0) total_millis = 1; // prevent divide by 0
            std.debug.print("Parse Time: {} millis ({}%)\n", .{ global_times.parse_time_millis, @divTrunc(100 * global_times.parse_time_millis, total_millis) });
            std.debug.print("Read Time : {} millis ({}%)\n", .{ global_times.read_time_millis, @divTrunc(100 * global_times.read_time_millis, total_millis) });
            std.debug.print("Gen Time  : {} millis ({}%)\n", .{ global_times.generate_time_millis, @divTrunc(100 * global_times.generate_time_millis, total_millis) });
            std.debug.print("Total Time: {} millis\n", .{total_millis});
        }
    }
    global_symbol_none = try global_symbol_pool.add("none");
    global_symbol_None = try global_symbol_pool.add("None");

    const all_args = try std.process.argsAlloc(allocator);
    // don't care about freeing args

    const cmd_args = all_args[1..];
    if (cmd_args.len != 5) {
        std.log.err("expected 5 cmdline arguments but got {}", .{cmd_args.len});
        return 1;
    }
    const extra_filename = cmd_args[0];
    const win32json_path = cmd_args[1];
    const pass1_json = cmd_args[2];
    const com_overloads_filename = cmd_args[3];
    const zigwin32_out_path = stripDotDir(cmd_args[4]);

    const version = blk: {
        var win32json_dir = try std.fs.cwd().openDir(win32json_path, .{});
        defer win32json_dir.close();
        const file = try win32json_dir.openFile("version.txt", .{});
        defer file.close();
        break :blk try file.reader().readAllAlloc(allocator, 100);
    };
    defer allocator.free(version);
    _ = std.SemanticVersion.parse(version) catch |err|
        fatal("version '{s}' is not a valid semantic version: {s}", .{ version, @errorName(err) });

    const pass1_json_content = blk: {
        var file = try std.fs.cwd().openFile(pass1_json, .{});
        defer file.close();
        break :blk try file.readToEndAlloc(allocator, std.math.maxInt(usize));
    };
    // no need to free pass1_json_content
    global_pass1 = pass1data.parseRoot(allocator, pass1_json, pass1_json_content);
    const api_list: []StringPool.Val = blk: {
        var api_list = std.ArrayList(StringPool.Val).init(allocator);
        const api_path = try std.fs.path.join(allocator, &.{ win32json_path, "api" });
        var api_dir = try std.fs.cwd().openDir(api_path, .{ .iterate = true });
        defer api_dir.close();
        var it = api_dir.iterate();
        while (try it.next()) |entry| {
            if (!std.mem.endsWith(u8, entry.name, ".json")) {
                std.log.err("expected all files to end in '.json' but got '{s}'\n", .{entry.name});
                return error.AlreadyReported;
            }
            const name_len = entry.name.len - ".json".len;
            const api = try global_symbol_pool.add(entry.name[0..name_len]);
            try api_list.append(api);
        }
        break :blk try api_list.toOwnedSlice();
    };
    // sort the list of APIs so our api order is not dependent on the file-system ordering
    std.mem.sort(StringPool.Val, api_list, {}, StringPool.asciiLessThanIgnoreCase);

    const api_set = blk: {
        var api_set: StringPool.HashMapUnmanaged(void) = .{};
        for (api_list) |api| {
            try api_set.putNoClobber(allocator, api, {});
        }
        break :blk api_set;
    };

    const extra_content = blk: {
        var file = try std.fs.cwd().openFile(extra_filename, .{});
        defer file.close();
        break :blk try file.readToEndAlloc(allocator, std.math.maxInt(usize));
    };
    // no need to free extra_content
    global_extra = extra.read(api_set, &global_symbol_pool, allocator, extra_filename, extra_content);
    // no need to free
    try readComOverloads(api_set, &global_com_overloads, com_overloads_filename);

    try cleanDir(std.fs.cwd(), zigwin32_out_path);
    var out_dir = try std.fs.cwd().openDir(zigwin32_out_path, .{});
    defer out_dir.close();
    try out_dir.makeDir("win32");

    const static_zig_files = [_][]const u8{
        "zig",
        "windowlongptr",
    };

    inline for (static_zig_files) |name| {
        try installStaticFile(out_dir, "win32/" ++ name ++ ".zig");
    }

    const static_files = [_][]const u8{
        "build.zig",
        "LICENSE",
        "README.md",
        ".gitignore",
        "zig.mod",
    };
    inline for (static_files) |name| {
        try installStaticFile(out_dir, name);
    }

    const root_module = try Module.alloc(null, try global_symbol_pool.add("win32"));

    {
        const api_path = try std.fs.path.join(allocator, &.{ win32json_path, "api" });
        var api_dir = try std.fs.cwd().openDir(api_path, .{ .iterate = true });
        defer api_dir.close();

        std.debug.print("-----------------------------------------------------------------------\n", .{});
        std.debug.print("loading {} api json files...\n", .{api_list.len});

        var out_win32_dir = try out_dir.openDir("win32", .{});
        defer out_win32_dir.close();

        for (api_list, 0..) |api_name, api_index| {
            const api_num = api_index + 1;
            var basename_buf: [100]u8 = undefined;
            const basename = std.fmt.bufPrint(&basename_buf, "{}.json", .{api_name}) catch @panic("basename_buf not big enough");
            std.debug.print("{}/{}: loading '{s}'\n", .{ api_num, api_list.len, basename });
            //
            // TODO: would things run faster if I just memory mapped the file?
            //
            var file = try api_dir.openFile(basename, .{});
            defer file.close();
            try readAndGenerateApiFile(root_module, out_win32_dir, api_path, basename, file);
        }

        if (global_missing_com_overloads.items.len > 0) {
            std.log.err(
                "missing {} entries in ComOverloads.txt, copy/paste the following to it:",
                .{global_missing_com_overloads.items.len},
            );
            for (global_missing_com_overloads.items) |overload| {
                try std.io.getStdErr().writer().print(
                    "{s} {s} {s} {} TODO_FILL_IN_SUFFIX\n",
                    .{
                        overload.api,
                        overload.com_type,
                        overload.method,
                        overload.method_index,
                    },
                );
            }
            std.process.exit(0xff);
        }

        for (static_zig_files ++ &[_][]const u8{
            "everything",
        }) |submodule_str| {
            const submodule = try global_symbol_pool.add(submodule_str);
            try root_module.children.put(submodule, try Module.alloc(root_module, submodule));
        }

        try generateContainerModules(out_dir, root_module);
        try generateEverythingModule(out_win32_dir, root_module);
    }

    {
        var zon = try out_dir.createFile("build.zig.zon", .{});
        defer zon.close();
        const w = zon.writer();
        try w.writeAll(".{\n");
        try w.writeAll("    .name = \"zigwin32\",\n");
        try w.print("    .version = \"{s}\",\n", .{version});
        try w.writeAll("    .minimum_zig_version = \"0.12.0\",\n");
        try w.writeAll("    .paths = .{\n");
        for (static_files) |name| {
            if (std.mem.eql(u8, name, ".gitignore")) continue;
            try w.print("        \"{s}\",\n", .{name});
        }
        try w.writeAll("        \"build.zig.zon\",\n");
        try w.writeAll("        \"win32\",\n");
        try w.writeAll("        \"win32.zig\",\n");
        try w.writeAll("    },\n");
        try w.writeAll("}\n");
    }
    print_time_summary = true;
    return 0;
}

fn stripDotDir(path: []const u8) []const u8 {
    if (std.mem.endsWith(u8, path, "/."))
        return path[0 .. path.len - 2];
    return path;
}

fn installStaticFile(out_dir: std.fs.Dir, comptime name: []const u8) !void {
    const file = try out_dir.createFile(name, .{});
    defer file.close();
    // NOTE: it's important that we use @embedFile here so that the genzig
    //       executable tracks changes to these files
    try file.writer().writeAll(@embedFile("static/" ++ name));
}

fn readJson(comptime T: type, filename: []const u8, content: []const u8) T {
    var diagnostics = std.json.Diagnostics{};
    var scanner = std.json.Scanner.initCompleteInput(allocator, content);
    defer scanner.deinit();
    scanner.enableDiagnostics(&diagnostics);
    return std.json.parseFromTokenSourceLeaky(
        T,
        allocator,
        &scanner,
        .{},
    ) catch |err| {
        std.log.err(
            "{s}:{}:{}: {s}",
            .{
                filename,
                diagnostics.getLine(),
                diagnostics.getColumn(),
                @errorName(err),
            },
        );
        @panic("json error");
    };
}

const ComSuffixMap = std.AutoHashMapUnmanaged(u16, []const u8);
const ComMethodMap = std.StringHashMapUnmanaged(ComSuffixMap);
const ComTypeMap = std.StringHashMapUnmanaged(ComMethodMap);

fn readComOverloads(
    api_name_set: StringPool.HashMapUnmanaged(void),
    api_map: *StringPool.HashMapUnmanaged(ComTypeMap),
    filename: []const u8,
) !void {
    var file = try std.fs.cwd().openFile(filename, .{});
    defer file.close();
    const content = try file.readToEndAlloc(allocator, std.math.maxInt(usize));
    // don't free, we'll keep the strings around
    var lines = std.mem.splitScalar(u8, content, '\n');
    var line_number: u32 = 1;
    while (lines.next()) |line| : (line_number += 1) {
        if (line.len == 0) continue;
        var field_it = std.mem.tokenize(u8, line, " ");
        const api = try global_symbol_pool.add(field_it.next() orelse continue);
        if (api_name_set.get(api)) |_| {} else fatal("{s} line {}: unknown api '{}'", .{ filename, line_number, api });
        const com_type = field_it.next() orelse fatal("{s} line {}: missing type field", .{ filename, line_number });
        const method = field_it.next() orelse fatal("{s} line {}: missing method field", .{ filename, line_number });
        const method_index_str = field_it.next() orelse fatal("{s} line {}: missing method index field", .{ filename, line_number });
        const method_index = std.fmt.parseInt(u16, method_index_str, 10) catch |err| fatal(
            "{s} line {}: invalid method index '{s}': {s}",
            .{ filename, line_number, method_index_str, @errorName(err) },
        );
        const suffix = field_it.next() orelse fatal("{s} line {}: missing suffix field", .{ filename, line_number });
        if (field_it.next()) |f| fatal(
            "{s} line {}: has extra field '{s}'",
            .{ filename, line_number, f },
        );

        const api_entry = try api_map.getOrPut(allocator, api);
        if (!api_entry.found_existing) {
            api_entry.value_ptr.* = .{};
        }
        const type_map = api_entry.value_ptr;
        const type_entry = try type_map.getOrPut(allocator, com_type);
        if (!type_entry.found_existing) {
            type_entry.value_ptr.* = .{};
        }
        const method_map = type_entry.value_ptr;
        const method_entry = try method_map.getOrPut(allocator, method);
        if (!method_entry.found_existing) {
            method_entry.value_ptr.* = .{};
        }
        const suffix_map = method_entry.value_ptr;
        const suffix_entry = try suffix_map.getOrPut(allocator, method_index);
        if (suffix_entry.found_existing) fatal(
            "api '{s}' type '{s}' method '{s}' has duplicate entries for index {}",
            .{ api, com_type, method, method_index },
        );
        suffix_entry.value_ptr.* = suffix;
    }
}

fn gatherSdkFiles(sdk_files: *ArrayList(*SdkFile), module: *Module) anyerror!void {
    if (module.file) |_| {
        try sdk_files.append(&module.file.?);
    }
    const children = try common.allocMapValues(allocator, *Module, module.children);
    defer allocator.free(children);
    std.mem.sort(*Module, children, {}, moduleLessThan); // sort so the order is predictable
    for (children) |child| {
        try gatherSdkFiles(sdk_files, child);
    }
}

fn generateEverythingModule(out_win32_dir: std.fs.Dir, root_module: *Module) !void {
    var everything_file = try out_win32_dir.createFile("everything.zig", .{});
    defer everything_file.close();
    var buffered_writer = BufferedWriter{ .unbuffered_writer = everything_file.writer() };
    defer buffered_writer.flush() catch @panic("flush failed");
    const writer = buffered_writer.writer();
    try writer.writeAll(&comptime removeCr(autogen_header ++
        \\//! This module contains aliases to ALL symbols inside the Win32 SDK.  It allows
        \\//! an application to access any and all symbols through a single import.
        \\
        \\pub const zig = @import("zig.zig");
        \\pub const L = zig.L;
        \\pub const closeHandle = zig.closeHandle;
        \\pub const loword = zig.loword;
        \\pub const hiword = zig.hiword;
        \\pub const has_window_longptr = zig.has_window_longptr;
        \\pub const getWindowLongPtr = zig.getWindowLongPtr;
        \\pub const setWindowLongPtr = zig.setWindowLongPtr;
        \\pub const getWindowLongPtrA = zig.getWindowLongPtrA;
        \\pub const setWindowLongPtrA = zig.setWindowLongPtrA;
        \\pub const getWindowLongPtrW = zig.getWindowLongPtrW;
        \\pub const setWindowLongPtrW = zig.setWindowLongPtrW;
        \\pub const scaleDpi = zig.scaleDpi;
        \\pub const dpiFromHwnd = zig.dpiFromHwnd;
        \\pub const invalidateHwnd = zig.invalidateHwnd;
        \\
    ));

    var sdk_files = ArrayList(*SdkFile).init(allocator);
    defer sdk_files.deinit();

    try gatherSdkFiles(&sdk_files, root_module);

    // TODO: workaround issue where constants/functions are defined more than once, not sure what the right solution
    //       is for all these, maybe some modules are not compatible with each other.  This could just be the permanent
    //       solution as well, if there are conflicts, we could just say the user has to import the specific module they want.
    // TODO: I think the right way to reslve conflicts in everything.zig is to have a priority order for the apis.
    //       If I just sort the API's in the right order, more common apis go first, then my current logic will work.
    var shared_export_map = StringPool.HashMap(*SdkFile).init(allocator);
    defer shared_export_map.deinit();

    // populate the shared_export_map, start with types first
    // because types can be referenced within the modules (unlike consts/functions)
    for (sdk_files.items) |sdk_file| {
        var type_export_it = sdk_file.type_exports.iterator();
        while (type_export_it.next()) |kv| {
            const type_name = kv.key_ptr.*;
            if (shared_export_map.get(type_name)) |_| {
                //try shared_export_map.put(type_name, .{ .first_sdk_file_ptr = entry.first_sdk_file_ptr, .duplicates = entry.duplicates + 1 });
            } else {
                //try shared_export_map.put(type_name, .{ .first_sdk_file_ptr = sdk_file, .duplicates = 0 });
                try shared_export_map.put(type_name, sdk_file);
            }
        }
    }

    for (sdk_files.items) |sdk_file| {
        try writer.print("// {s} exports {} constants:\n", .{ sdk_file.zig_name, sdk_file.const_exports.items.len });
        for (sdk_file.const_exports.items) |constant| {
            if (shared_export_map.get(constant)) |other_sdk_file| {
                try writer.print("// WARNING: redifinition of constant symbol '{s}' in module '{s}' (going with module '{s}')\n", .{ constant, sdk_file.zig_name, other_sdk_file.zig_name });
            } else {
                try writer.print("pub const {s} = @import(\"../win32.zig\").{s}.{0s};\n", .{ constant, sdk_file.zig_name });
                try shared_export_map.put(constant, sdk_file);
            }
        }
        try writer.print("// {s} exports {} types:\n", .{ sdk_file.zig_name, sdk_file.type_exports.count() });
        var export_it = sdk_file.type_exports.iterator();
        while (export_it.next()) |kv| {
            const type_name = kv.key_ptr.*;
            const first_type_sdk = shared_export_map.get(type_name) orelse unreachable;
            if (first_type_sdk != sdk_file) {
                try writer.print("// WARNING: redefinition of type symbol '{s}' from '{s}', going with '{s}'\n", .{ type_name, sdk_file.zig_name, first_type_sdk.zig_name });
            } else {
                try writer.print("pub const {s} = @import(\"../win32.zig\").{s}.{0s};\n", .{ type_name, sdk_file.zig_name });
            }
        }
        try writer.print("// {s} exports {} functions:\n", .{ sdk_file.zig_name, sdk_file.func_exports.count() });
        var func_it = sdk_file.func_exports.iterator();
        while (func_it.next()) |kv| {
            const func = kv.key_ptr.*;
            if (shared_export_map.get(func)) |other_sdk_file| {
                try writer.print("// WARNING: redifinition of function '{s}' in module '{s}' (going with module '{s}')\n", .{ func, sdk_file.zig_name, other_sdk_file.zig_name });
            } else {
                try writer.print("pub const {s} = @import(\"../win32.zig\").{s}.{0s};\n", .{ func, sdk_file.zig_name });
                try shared_export_map.put(func, sdk_file);
            }
        }
    }
}

fn moduleLessThan(context: void, lhs: *Module, rhs: *Module) bool {
    _ = context;
    return std.ascii.lessThanIgnoreCase(lhs.name.slice, rhs.name.slice);
}

fn generateContainerModules(dir: std.fs.Dir, module: *Module) anyerror!void {
    if (module.children.count() == 0) {
        return;
    }

    var file = blk: {
        if (module.file) |_| {
            const file = try dir.openFile(module.zig_basename, .{ .mode = .write_only });
            try file.seekFromEnd(0);
            break :blk file;
        }
        break :blk try dir.createFile(module.zig_basename, .{});
    };
    defer file.close();
    var buffered_writer = BufferedWriter{ .unbuffered_writer = file.writer() };
    defer buffered_writer.flush() catch @panic("flush failed");
    const writer = buffered_writer.writer();

    const children = try common.allocMapValues(allocator, *Module, module.children);
    defer allocator.free(children);

    std.mem.sort(*Module, children, {}, moduleLessThan);
    if (module.file) |_| {
        try writer.print("//--------------------------------------------------------------------------------\n", .{});
        try writer.print("// Section: SubModules ({})\n", .{children.len});
        try writer.print("//--------------------------------------------------------------------------------\n", .{});
    } else {
        try writer.writeAll(autogen_header);
    }
    for (children) |child| {
        try writer.print("pub const {s} = @import(\"{s}/{0s}.zig\");\n", .{ child.name, module.name.slice });
    }

    if (module.file) |_| {} else {
        try writer.writeAll(&comptime removeCr(
            \\test {
            \\    @import("std").testing.refAllDecls(@This());
            \\}
            \\
        ));
    }

    var next_dir = try dir.openDir(module.name.slice, .{});
    defer next_dir.close();

    for (children) |child| {
        try generateContainerModules(next_dir, child);
    }
}

fn readAndGenerateApiFile(
    root_module: *Module,
    out_dir: std.fs.Dir,
    api_path: []const u8,
    json_basename: []const u8,
    file: std.fs.File,
) !void {
    var json_arena_instance = std.heap.ArenaAllocator.init(allocator);
    defer json_arena_instance.deinit();
    const json_arena = json_arena_instance.allocator();

    const read_start_millis = std.time.milliTimestamp();
    const content = try file.readToEndAlloc(json_arena, std.math.maxInt(usize));
    // no need to free content, owned by json_arena
    const read_end_millis = std.time.milliTimestamp();
    global_times.read_time_millis += read_end_millis - read_start_millis;
    std.debug.print("  read {} bytes\n", .{content.len});

    const json_root = metadata.Api.parse(json_arena, api_path, json_basename, content);
    // no need to free json_root, owned by json_arena
    global_times.parse_time_millis += std.time.milliTimestamp() - read_end_millis;

    const json_basename_copy = try allocator.dupe(u8, json_basename);
    const json_name = try global_symbol_pool.add(json_basename_copy[0 .. json_basename_copy.len - ".json".len]);
    const zig_name = try cameltosnake.camelToSnakeAlloc(allocator, json_name.slice);
    errdefer allocator.free(zig_name);

    var module_dir = out_dir;
    defer if (module_dir.fd != out_dir.fd) module_dir.close();

    var module: *Module = root_module;
    var depth: u2 = 0;

    {
        var it = std.mem.tokenize(u8, zig_name, ".");
        while (it.next()) |name_part| {
            if (module != root_module) {
                depth += 1;
                if (module.children.count() == 0) {
                    try module_dir.makeDir(module.name.slice);
                }
                const next_dir = try module_dir.openDir(module.name.slice, .{});
                if (module_dir.fd != out_dir.fd)
                    module_dir.close();
                module_dir = next_dir;
            }

            const name_pool = try global_symbol_pool.add(name_part);
            if (module.children.get(name_pool)) |existing| {
                module = existing;
            } else {
                const new_module = try Module.alloc(module, name_pool);
                try module.children.put(name_pool, new_module);
                module = new_module;
            }
        }
    }

    if (module.file) |_| {
        jsonPanicMsg("qualified name '{s}' already has an sdk file?", .{zig_name});
    }

    var extra_funcs: extra.Functions = .{};
    var extra_consts: extra.Constants = .{};
    if (global_extra.get(json_name)) |api_obj| {
        extra_funcs = api_obj.functions;
        extra_consts = api_obj.constants;
    }

    module.file = SdkFile{
        .json_basename = json_basename_copy,
        .json_name = json_name,
        .zig_name = zig_name,
        .depth = depth,
        .const_exports = ArrayList(StringPool.Val).init(allocator),
        .uses_guid = false,
        .top_level_api_imports = StringPool.HashMap(ApiImport).init(allocator),
        .type_exports = StringPoolArrayHashMap(void).init(allocator),
        .func_exports = StringPoolArrayHashMap(void).init(allocator),
        .tmp_func_ptr_workaround_list = ArrayList(StringPool.Val).init(allocator),
        .method_conflict_map = getMethodConflictMap(json_name.slice),
        .param_conflict_map = getParamConflictMap(json_name.slice),
        .extra_funcs = extra_funcs,
        .extra_funcs_applied = StringPool.HashMap(void).init(allocator),
        .extra_consts = extra_consts,
        .extra_consts_applied = StringPool.HashMap(void).init(allocator),
        .com_type_overloads = global_com_overloads.get(json_name),
    };

    const generate_start_millis = std.time.milliTimestamp();
    try generateFile(module_dir, module, json_root);
    global_times.generate_time_millis += std.time.milliTimestamp() - generate_start_millis;
}

pub fn EmptyStaticStringMap(comptime V: type) type {
    return struct {
        pub fn get(str: []const u8) ?V {
            _ = str;
            return null;
        }
    };
}

fn ArchSpecificMap(comptime T: type) type {
    return StringPoolArrayHashMap(ArchSpecificObjects(T));
}

fn generateFile(module_dir: std.fs.Dir, module: *Module, api: metadata.Api) !void {
    const sdk_file = &module.file.?;

    var out_file = try module_dir.createFile(module.zig_basename, .{});
    defer out_file.close();
    var buffered_writer = BufferedWriter{ .unbuffered_writer = out_file.writer() };
    defer buffered_writer.flush() catch @panic("flush failed");
    var code_writer = CodeWriter{ .writer = buffered_writer.writer(), .depth = 0, .midline = false };
    // need to specify type explicitly because of https://github.com/ziglang/zig/issues/12795
    const writer: *CodeWriter = &code_writer;

    try writer.writeBlock(autogen_header);
    // We can't import the everything module because it will re-introduce the same symbols we are exporting
    //try writer.print("usingnamespace @import(\"everything.zig\");\n", .{});
    try writer.line("//--------------------------------------------------------------------------------");
    try writer.linef("// Section: Constants ({})", .{api.Constants.len});
    try writer.line("//--------------------------------------------------------------------------------");
    for (api.Constants) |constant| {
        try generateConstant(sdk_file, writer, constant);
    }
    std.debug.assert(api.Constants.len == sdk_file.const_exports.items.len);
    try writer.line("");
    try writer.line("//--------------------------------------------------------------------------------");
    try writer.linef("// Section: Types ({})", .{api.Types.len});
    try writer.line("//--------------------------------------------------------------------------------");
    {
        var arch_specific_types = ArchSpecificMap(metadata.Type).init(allocator);
        defer arch_specific_types.deinit();
        var enum_alias_conflicts = StringPool.HashMap(StringPool.Val).init(allocator);
        defer enum_alias_conflicts.deinit();
        for (api.Types) |t| {
            try generateType(sdk_file, writer, &arch_specific_types, t, &enum_alias_conflicts);
            try writer.line("");
        }
        var it = arch_specific_types.iterator();
        while (it.next()) |entry| {
            const name = entry.key_ptr.*;
            try writer.linef(
                "pub const {s} = switch(@import(\"{s}zig.zig\").arch) {{",
                .{ name, import_prefix_table[sdk_file.depth] },
            );
            var combined_arches: metadata.Architectures = .{ .filter = .{} };
            for (entry.value_ptr.getItemsConst()) |object| {
                combined_arches = combined_arches.unionWith(.{ .filter = object.filter });
                var buf: [40]u8 = undefined;
                const def_prefix = buf[0..try formatArchesCase(object.filter, &buf)];
                writer.depth += 1;
                defer writer.depth -= 1;
                // Enforce the type arches match the arches we filtered the type on.
                // If it doesn't we might need to update generateTypeDefinition to take an extra
                // arches parameter.
                std.debug.assert(object.obj.Architectures.eql(.{ .filter = object.filter }));
                try generateTypeDefinition(sdk_file, writer, object.obj, &enum_alias_conflicts, name, def_prefix, ",");
            }
            if (combined_arches.filter != null) {
                //try writer.line("    else => @compileError(\"unsupported on this arch\"),");
                try writer.line("    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682");
            }
            try writer.line("};");
        }
    }
    try writer.line("");
    try writer.line("//--------------------------------------------------------------------------------");
    try writer.linef("// Section: Functions ({})", .{api.Functions.len});
    try writer.line("//--------------------------------------------------------------------------------");
    for (api.Functions) |function| {
        try generateFunction(sdk_file, writer, .{ .dll = function });
        try writer.line("");
    }
    std.debug.assert(api.Functions.len >= sdk_file.func_exports.count());
    try writer.line("");
    try writer.line("//--------------------------------------------------------------------------------");
    try writer.linef("// Section: Unicode Aliases ({})", .{api.UnicodeAliases.len});
    try writer.line("//--------------------------------------------------------------------------------");
    try generateUnicodeAliases(sdk_file, writer, api.UnicodeAliases);
    const import_total = @intFromBool(sdk_file.uses_guid) + sdk_file.top_level_api_imports.count();
    try writer.line("//--------------------------------------------------------------------------------");
    try writer.linef("// Section: Imports ({})", .{import_total});
    try writer.line("//--------------------------------------------------------------------------------");
    if (sdk_file.uses_guid) {
        try writer.linef("const Guid = @import(\"{s}zig.zig\").Guid;", .{sdk_file.getWin32DirImportPrefix()});
    }
    {
        var arch_specific_imports = ArchSpecificMap(StringPool.Val).init(allocator);
        defer arch_specific_imports.deinit();

        const NamedApiImport = struct {
            name: StringPool.Val,
            import: ApiImport,
            pub fn asciiLessThanIgnoreCase(_: void, lhs: @This(), rhs: @This()) bool {
                return std.ascii.lessThanIgnoreCase(lhs.name.slice, rhs.name.slice);
            }
        };
        var sorted_imports = std.ArrayList(NamedApiImport).init(allocator);
        defer sorted_imports.deinit();
        {
            var it = sdk_file.top_level_api_imports.iterator();
            while (it.next()) |entry| {
                try sorted_imports.append(.{ .name = entry.key_ptr.*, .import = entry.value_ptr.* });
            }
        }
        std.mem.sort(NamedApiImport, sorted_imports.items, {}, NamedApiImport.asciiLessThanIgnoreCase);

        // print the arch-agnostic imports first
        for (sorted_imports.items) |import| {
            const api_upper = import.import.api;
            const arches = import.import.arches;

            if (arches.filter) |filter| {
                try addArchSpecific(StringPool.Val, &arch_specific_imports, import.name, filter, api_upper);
            } else {
                // TODO: should I cache this mapping from api ref to api import path?
                const api_path = try allocApiImportPathFromRef(api_upper.slice);
                defer allocator.free(api_path);
                try writer.linef("const {s} = @import(\"{s}{s}.zig\").{0s};", .{ import.name, sdk_file.getWin32DirImportPrefix(), api_path });
            }
        }
        if (arch_specific_imports.count() > 0) {
            try writer.linef("// {} arch-specific imports", .{arch_specific_imports.count()});
            var arch_imports_it = arch_specific_imports.iterator();
            while (arch_imports_it.next()) |arch_import_node| {
                const name = arch_import_node.key_ptr.*;
                try writer.linef("const {s} = switch(@import(\"{s}zig.zig\").arch) {{", .{ name, import_prefix_table[sdk_file.depth] });
                var combined_arches: metadata.Architectures = .{ .filter = .{} };
                for (arch_import_node.value_ptr.getItemsConst()) |object| {
                    combined_arches = combined_arches.unionWith(.{ .filter = object.filter });
                    var buf: [40]u8 = undefined;
                    const def_prefix = buf[0..try formatArchesCase(object.filter, &buf)];
                    const api_upper = object.obj;
                    // TODO: should I cache this mapping from api ref to api import path?
                    const api_path = try allocApiImportPathFromRef(api_upper.slice);
                    defer allocator.free(api_path);
                    try writer.linef("    {s}@import(\"{s}{s}.zig\").{s},", .{ def_prefix, sdk_file.getWin32DirImportPrefix(), api_path, name });
                }
                if (combined_arches.filter != null) {
                    //try writer.line("    else => @compileError(\"unsupported on this arch\"),");
                    try writer.line("    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682");
                }
                try writer.line("};");
            }
        }
    }

    try writer.writeBlock(&comptime removeCr(
        \\
        \\test {
        \\
    ));
    if (sdk_file.tmp_func_ptr_workaround_list.items.len > 0) {
        try writer.line("    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476");
        for (sdk_file.tmp_func_ptr_workaround_list.items) |func_ptr_type| {
            try writer.linef("    if (@hasDecl(@This(), \"{s}\")) {{ _ = {0s}; }}", .{func_ptr_type});
        }
        try writer.line("");
    }
    try writer.writeBlock(&comptime removeCr(
        \\    @setEvalBranchQuota(
        \\        comptime @import("std").meta.declarations(@This()).len * 3
        \\    );
        \\
        \\    // reference all the pub declarations
        \\    if (!@import("builtin").is_test) return;
        \\    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        \\        _ = @field(@This(), decl.name);
        \\    }
        \\}
        \\
    ));

    // check that all extra stuff was applied
    {
        var it = sdk_file.extra_funcs.iterator();
        var error_count: u32 = 0;
        while (it.next()) |notnull_api| {
            const name = notnull_api.key_ptr.*;
            if (sdk_file.extra_funcs_applied.get(name)) |_| {} else {
                std.log.err("extra.txt api '{s}' function '{s}' was not applied", .{ sdk_file.json_name, name });
                error_count += 1;
            }
        }
        sdk_file.extra_funcs_applied.deinit();
        if (error_count > 0) {
            std.process.exit(0xff);
        }
    }
    {
        var it = sdk_file.extra_consts.iterator();
        var error_count: u32 = 0;
        while (it.next()) |up_api| {
            const pool_name = up_api.key_ptr.*;
            if (sdk_file.extra_consts_applied.get(pool_name)) |_| {} else {
                std.log.err("extra.txt api '{s}' constant '{s}' was not applied", .{ sdk_file.json_name, pool_name });
                error_count += 1;
            }
        }
        sdk_file.extra_consts_applied.deinit();
        if (error_count > 0) {
            std.process.exit(0xff);
        }
    }
}

// TODO: should I cache this mapping from api ref to api import path?
fn allocApiImportPathFromRef(api_ref: []const u8) ![]u8 {
    const api_path = try cameltosnake.camelToSnakeAlloc(allocator, api_ref);
    for (api_path, 0..) |c, i| {
        if (c == '.')
            api_path[i] = '/';
    }
    return api_path;
}

// convenient function that combines both adding type refs and creating a formatter
// for the type.   These 2 operations are orthogonal, however, combining them helps ensure
// that generating a type reference is not done without also adding that reference to the api
// being generated.
fn addTypeRefs(
    sdk_file: *SdkFile,
    arches: metadata.Architectures,
    type_ref: metadata.TypeRef,
    options: TypeRefFormatter.Options,
    nested_context: ?*const NestedContext,
) anyerror!TypeRefFormatter {
    try addTypeRefsNoFormatter(sdk_file, arches, type_ref);
    return fmtTypeRef(type_ref, arches, options, nested_context);
}

fn addTypeRefsNoFormatter(sdk_file: *SdkFile, arches: metadata.Architectures, type_ref: metadata.TypeRef) anyerror!void {
    switch (type_ref) {
        .Native => |native| switch (native.Name) {
            .Guid => sdk_file.uses_guid = true,
            else => {},
        },
        .ApiRef => |api_ref| {
            const name = getApiRefSubstitute(api_ref.Name, api_ref.Parents) orelse api_ref.Name;
            const api = try global_symbol_pool.add(api_ref.Api);
            try sdk_file.addApiImport(arches, name, api, api_ref.Parents);
        },
        .PointerTo => |to| try addTypeRefsNoFormatter(sdk_file, arches, to.Child.*),
        .Array => |a| try addTypeRefsNoFormatter(sdk_file, arches, a.Child.*),
        .LPArray => |a| try addTypeRefsNoFormatter(sdk_file, arches, a.Child.*),
        .MissingClrType => {},
    }
}

pub fn isAnonymousTypeName(name: []const u8) bool {
    if (std.mem.endsWith(u8, name, "_e__Struct")) {
        return true;
    }
    if (std.mem.endsWith(u8, name, "_e__Union")) {
        return true;
    }
    return false;
}

// Provides access to nested types accessible from the current scope
const NestedContext = struct {
    nested_types: []const metadata.Type,
    parent: ?*const NestedContext,

    pub fn contains(self: NestedContext, name: []const u8) bool {
        std.debug.assert(self.nested_types.len > 0);
        for (self.nested_types) |*nested_type| {
            if (std.mem.eql(u8, nested_type.Name, name))
                return true;
        }
        if (self.parent) |p| return p.contains(name);
        return false;
    }
};

// we need to know if the type is the top-level type or a child type of something like a pointer
// so we can generate the correct `void` type.  Top level void types become void, but pointers
// to void types must become pointers to the `anyopaque` type.
// Need to know if it is an array specifically because array pointers cannot point to opaque types
// with an unknown size.
const DepthContext = enum { top_level, child, array };
const ComOutPtrContext = enum { outer_pointer, inner_pointer };
const TypeRefFormatter = struct {
    pub const Reason = enum { var_decl, direct_type_access };
    pub const Options = struct {
        reason: Reason,

        is_const: bool,
        in: bool,
        out: bool,
        optional: bool,
        not_null_term: bool,
        // TODO: handle this option
        null_null_term: bool,
        // TODO: what to do with this?
        //ret_val: bool,
        com_out_ptr: ?ComOutPtrContext,
        // TODO: don't know what to do with this yet
        //do_not_release: bool,
        // TODO: don't know what to do with this yet
        //reserved: bool,
        optional_bytes_param_index: ?u16,

        anon_types: ?*const AnonTypes,
        extra_mod: extra.TypeModifier,

        pub fn defaults(opt: struct {
            reason: Reason,
            is_const: bool = false,
            in: bool = false,
            out: bool = false,
            optional: bool = false,
            not_null_term: bool = false,
            null_null_term: bool = false,
            com_out_ptr: ?ComOutPtrContext = null,
            optional_bytes_param_index: ?u16 = null,
            anon_types: ?*const AnonTypes = null,
            extra_mod: extra.TypeModifier = .{},
        }) Options {
            return .{
                .reason = opt.reason,
                .is_const = opt.is_const,
                .in = opt.in,
                .out = opt.out,
                .optional = opt.optional,
                .not_null_term = opt.not_null_term,
                .null_null_term = opt.null_null_term,
                .com_out_ptr = opt.com_out_ptr,
                .optional_bytes_param_index = opt.optional_bytes_param_index,
                .anon_types = opt.anon_types,
                .extra_mod = opt.extra_mod,
            };
        }
        pub fn fromParamAttrs(
            attrs: metadata.ParamAttrs,
            reason: TypeRefFormatter.Reason,
            modifiers: extra.TypeModifier,
        ) Options {
            if (attrs.FreeWith) |free_with| {
                // TODO: what do we do with this
                _ = free_with.Func;
            }
            return .{
                .reason = reason,

                .is_const = attrs.Const,
                .in = attrs.In,
                .out = attrs.Out,
                .optional = attrs.Optional,
                .not_null_term = attrs.NotNullTerminated,
                .null_null_term = attrs.NullNullTerminated,
                //.ret_val = attrs.RetVal,
                .com_out_ptr = if (attrs.ComOutPtr) .outer_pointer else null,
                //.do_not_release = attrs.DoNotRelease,
                //.reserved = attrs.Reserved,
                .optional_bytes_param_index = if (attrs.MemorySize) |m| m.BytesParamIndex else null,

                .anon_types = null,
                .extra_mod = modifiers,
            };
        }
        pub fn getChildOptions(self: Options) Options {
            var child_options = self;

            if (self.com_out_ptr == .outer_pointer) {
                child_options.optional = false;
            }

            child_options.com_out_ptr = if (self.com_out_ptr) |c| switch (c) {
                .outer_pointer => .inner_pointer,
                else => null,
            } else null;

            child_options.extra_mod.null_modifier = self.extra_mod.null_modifier >> 1;
            return child_options;
        }
        pub fn allowOptionalPtr(
            self: Options,
        ) bool {
            // optional doesn't seem to be reliable enough to depend on it for this
            //if (!self.optional) return true;
            if (1 == (self.extra_mod.null_modifier & 1)) return false;
            if (self.com_out_ptr) |context| switch (context) {
                .outer_pointer => if (!self.optional) return false,
                .inner_pointer => return false,
            };
            return true;
        }
    };

    type_ref: metadata.TypeRef,
    arches: metadata.Architectures,
    options: Options,
    nested_context: ?*const NestedContext,
};
pub fn fmtTypeRef(
    type_ref: metadata.TypeRef,
    arches: metadata.Architectures,
    options: TypeRefFormatter.Options,
    nested_context: ?*const NestedContext,
) TypeRefFormatter {
    return .{ .type_ref = type_ref, .arches = arches, .options = options, .nested_context = nested_context };
}

fn generateTypeRef(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    self: TypeRefFormatter,
) !void {
    try generateTypeRefRec(sdk_file, writer, self, .top_level);
}
fn generateTypeRefRec(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    self: TypeRefFormatter,
    depth_context: DepthContext,
) anyerror!void {
    switch (self.type_ref) {
        .Native => |native| {
            const zig_type = zigTypeFromTypeRefNative(native.Name, depth_context);
            try writer.writef("{s}", .{zig_type}, .{ .start = .any, .nl = false });
        },
        .ApiRef => |api_ref| {
            const name = getApiRefSubstitute(api_ref.Name, api_ref.Parents) orelse api_ref.Name;
            if (isAnonymousTypeName(name)) {
                const anon_types = self.options.anon_types orelse
                    jsonPanicMsg("missing anonymous type '{s}' (this scope does not have any anonymous types)!", .{name});
                const name_pool = try global_symbol_pool.add(name);
                const t = anon_types.types.get(name_pool) orelse
                    jsonPanicMsg("missing anonymous type '{s}'!", .{name_pool});
                switch (t.Kind) {
                    .Struct => try generateStructOrUnionDef(sdk_file, writer, t, self.nested_context),
                    .Union => try generateStructOrUnionDef(sdk_file, writer, t, self.nested_context),
                    else => jsonPanic(),
                }
                try writer.write("}", .{ .nl = false });
                return;
            }

            const type_kind_category: Pass1TypeCategory = blk: {
                const pass1_api_map = global_pass1.get(api_ref.Api) orelse jsonPanicMsg("type '{s}' is from API '{s}' that is missing from pass1 data", .{ name, api_ref.Api });

                const pass1_type: pass1data.Type = pass1_api_map.get(name) orelse {
                    if (api_ref.Parents.len == 0) {
                        const in_nested_context = if (self.nested_context) |c| c.contains(name) else false;
                        if (!in_nested_context) jsonPanicMsg(
                            "type '{s}' from API '{s}' is missing from pass1 data, has no parents and is not in the current nested context!",
                            .{ name, api_ref.Api },
                        );
                    }
                    // this means its a nested type which are always structs/unions
                    break :blk .default;
                };
                break :blk getPass1TypeCategory(pass1_type);
            };

            if (self.options.reason == .var_decl) {
                switch (type_kind_category) {
                    .default => {},
                    .ptr => {
                        if (self.options.allowOptionalPtr()) {
                            try writer.write("?", .{ .start = .any, .nl = false });
                        }
                    },
                    .com => {
                        if (self.options.allowOptionalPtr()) {
                            try writer.write("?", .{ .start = .any, .nl = false });
                        }
                        try writer.write("*", .{ .start = .any, .nl = false });
                    },
                }
            }

            // special handling for PSTR and PWSTR for now.  This is because those types
            // have hardcoded non-const and null-terminated, so we can't reference them if our usage
            // doesn't match.
            // If there are more cases that behave like this, I will likely need to implement a 2-pass
            // system where the first pass I gather all the type definitions so that on the second pass
            // I'll know whether each type is a pointer like this and can fix things like this.
            const special: enum { pstr, pwstr, other } = blk: {
                if (std.mem.eql(u8, name, "PSTR")) break :blk .pstr;
                if (std.mem.eql(u8, name, "PWSTR")) break :blk .pwstr;
                break :blk .other;
            };
            if (special == .pstr or special == .pwstr) {
                // if we deviated from the options we set for PSTR/PWSTR, then generate the native zig
                // type directly instead of referencing the PSTR/PWSTR type
                if (self.options.is_const or self.options.not_null_term) {
                    // can't put these expressions in the print argument tuple because of https://github.com/ziglang/zig/issues/8036
                    const base_type = if (special == .pstr) "u8" else "u16";
                    const sentinel_suffix = if (self.options.not_null_term) "" else ":0";
                    const align_str = if (self.options.extra_mod.union_pointer) "align(1) " else "";
                    const const_str = if (self.options.is_const) "const " else "";
                    try writer.writef(
                        "[*{s}]{s}{s}{s}",
                        .{ sentinel_suffix, align_str, const_str, base_type },
                        .{ .start = .any, .nl = false },
                    );
                    return;
                }
            }

            // for now, all nested type references MUST be in the same scope so this
            // just causes issues
            //for (api_ref.Parents) |parent| {
            //    try writer.writef("{s}", .{parent}, .{.start=.any,.nl=false});
            //    try writer.write(".", .{.start=.any,.nl=false});
            //}
            try writer.writef("{s}", .{name}, .{ .start = .any, .nl = false });
        },
        .PointerTo => |to| {
            var child_options = self.options.getChildOptions();
            if (self.options.reason == .var_decl and self.options.allowOptionalPtr()) {
                try writer.write("?", .{ .start = .any, .nl = false });
            }
            try writer.write("*", .{ .start = .any, .nl = false });
            if (self.options.extra_mod.union_pointer) {
                try writer.write("align(1) ", .{ .start = .any, .nl = false });
            }
            if (self.options.is_const) {
                child_options.is_const = false; // TODO: this doesn't seem right
                try writer.write("const ", .{ .start = .any, .nl = false });
            }
            try generateTypeRefRec(sdk_file, writer, fmtTypeRef(to.Child.*, self.arches, child_options, self.nested_context), .child);
        },
        .Array => |array| {
            const shape_size: u32 = init: {
                if (array.Shape) |shape| break :init shape.Size;
                // TODO: should we use size 1 here?
                break :init 1;
            };
            try writer.writef("[{}]", .{shape_size}, .{ .start = .any, .nl = false });
            try generateTypeRefRec(sdk_file, writer, fmtTypeRef(array.Child.*, self.arches, self.options, self.nested_context), .child);
        },
        .LPArray => |array| {
            if (self.options.optional) {
                try writer.write("?", .{ .start = .any, .nl = false });
            }
            if (array.NullNullTerm) {
                try writer.write(
                    "*extern struct{{comment:[*]const u8=\"TODO: LPArray with null_null_term\"}}",
                    .{ .start = .any, .nl = false },
                );
            } else {
                var sentinel_suffix: []const u8 = "";
                if ((!self.options.not_null_term) and isByteOrCharOrUInt16Type(array.Child.*)) {
                    sentinel_suffix = ":0";
                }

                if (array.CountConst == -1 or array.CountConst == 0) {
                    try writer.writef("[*{s}]", .{sentinel_suffix}, .{ .start = .any, .nl = false });
                } else {
                    try writer.writef("*[{}]", .{array.CountConst}, .{ .start = .any, .nl = false });
                }
                if (array.CountConst <= 0 and self.options.is_const)
                    try writer.write("const ", .{ .start = .any, .nl = false });
                try generateTypeRefRec(sdk_file, writer, fmtTypeRef(array.Child.*, self.arches, self.options.getChildOptions(), self.nested_context), .array);
            }
        },
        .MissingClrType => |t| try writer.writef(
            "*struct{{comment: []const u8 = \"MissingClrType {s}.{s}\"}}",
            .{ t.Name, t.Namespace },
            .{ .start = .any, .nl = false },
        ),
    }
}

fn zigTypeFromTypeRefNative(
    name: metadata.TypeRefNative,
    depth_context: DepthContext,
) []const u8 {
    return switch (name) {
        .Void => switch (depth_context) {
            .top_level => "void",
            .child => "anyopaque",
            // if we are rendering the element of an array, then we have to know the size, we default to u8
            // because most void pointers in C are measured in terms of u8 bytes
            .array => "u8",
        },
        .Boolean => "bool",
        .SByte => "i8",
        .Byte => "u8",
        .Int16 => "i16",
        .UInt16 => "u16",
        .Int32 => "i32",
        .UInt32 => "u32",
        .Int64 => "i64",
        .UInt64 => "u64",
        .Char => "u16",
        .Single => "f32",
        .Double => "f64",
        .String => "[]const u8",
        .IntPtr => "isize",
        .UIntPtr => "usize",
        .Guid => "Guid",
    };
}

fn isByteOrCharOrUInt16Type(type_ref: metadata.TypeRef) bool {
    return switch (type_ref) {
        .Native => |t| switch (t.Name) {
            .Byte, .Char, .UInt16 => true,
            else => false,
        },
        else => false,
    };
}

fn fmtConstValue(value_type: metadata.ValueType, value: std.json.Value, sdk_file: *SdkFile) ConstValueFormatter {
    return .{ .value_type = value_type, .value = value, .sdk_file = sdk_file };
}
const ConstValueFormatter = struct {
    value_type: metadata.ValueType,
    value: std.json.Value,
    sdk_file: *SdkFile,
    pub fn format(
        self: @This(),
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        _ = fmt;
        _ = options;
        if (self.value_type == .String) {
            switch (self.value) {
                .null => try writer.writeAll("null"),
                .string => |s| try writer.print("\"{}\"", .{std.zig.fmtEscapes(s)}),
                else => std.debug.panic("uhandled type '{s}'", .{@tagName(self.value)}),
            }
            return;
        }
        const zig_type = zigTypeFromValueType(self.value_type);
        if (self.value_type == .Single or self.value_type == .Double) {
            switch (self.value) {
                .string => |float_str| {
                    if (std.mem.eql(u8, float_str, "inf")) {
                        try writer.print("@import(\"std\").math.inf({s})", .{zig_type});
                        return;
                    } else if (std.mem.eql(u8, float_str, "-inf")) {
                        try writer.print("-@import(\"std\").math.inf({s})", .{zig_type});
                        return;
                    } else if (std.mem.eql(u8, float_str, "nan")) {
                        try writer.print("@import(\"std\").math.nan({s})", .{zig_type});
                        return;
                    } else {
                        std.debug.panic("unexpected float string value '{s}'", .{float_str});
                    }
                    return;
                },
                else => {},
            }
        }
        try writer.print("@as({s}, {})", .{ zig_type, fmtJson(self.value) });
    }
};

const constants_to_skip = std.StaticStringMap(void).initComptime(.{
    // skip this constant because its name conflicts with the name of a type!
    .{"PEERDIST_RETRIEVAL_OPTIONS_CONTENTINFO_VERSION"},

    // HWND_DESKTOP and HWND_TOP are HWND types, but they are 0 so they need to be ?HWND
    .{"HWND_DESKTOP"},
    .{"HWND_TOP"},

    // This is both a constant and a type definition in Networking.HttpServer
    .{"HTTP_VERSION"},
});
fn generateConstant(sdk_file: *SdkFile, writer: *CodeWriter, constant: metadata.Constant) !void {
    const name_pool = try global_symbol_pool.add(constant.Name);
    try sdk_file.const_exports.append(name_pool);

    if (constants_to_skip.get(constant.Name)) |_| {
        try writer.linef("// skipped '{s}'", .{constant.Name});
        return;
    }

    var options = TypeRefFormatter.Options.defaults(.{
        .reason = .direct_type_access,
        .is_const = true,
    });
    if (sdk_file.extra_consts.get(name_pool)) |_| {
        try sdk_file.extra_consts_applied.put(name_pool, {});
        options.extra_mod.union_pointer = true;
    }

    const zig_type_formatter = try addTypeRefs(sdk_file, .{}, constant.Type, options, null);

    if (constant.Type == .Native) {
        jsonEnforce(constant.ValueType != .PropertyKey);
        if (constant.Type.Native.Name == .Guid) {
            try writer.linef("pub const {s} = Guid.initString({});", .{
                name_pool,
                fmtConstValue(constant.ValueType, constant.Value, sdk_file),
            });
        } else {
            try writer.linef("pub const {s} = {};", .{
                name_pool,
                fmtConstValue(constant.ValueType, constant.Value, sdk_file),
            });
        }
    } else {
        if (constant.ValueType == .PropertyKey) {
            const value_obj = switch (constant.Value) {
                .object => |obj| obj,
                else => jsonPanicMsg("expected PropertyKey to be an object but got: {s}", .{fmtJson(constant.Value)}),
            };
            try jsonObjEnforceKnownFieldsOnly(value_obj, &[_][]const u8{ "Fmtid", "Pid" }, sdk_file);
            const fmtid = (try jsonObjGetRequired(value_obj, "Fmtid", sdk_file)).string;
            const pid = (try jsonObjGetRequired(value_obj, "Pid", sdk_file)).integer;
            try writer.writef("pub const {s} = ", .{name_pool}, .{ .nl = false });
            try generateTypeRef(sdk_file, writer, zig_type_formatter);
            sdk_file.uses_guid = true;
            try writer.writef(" {{ .fmtid = Guid.initString(\"{s}\"), .pid = {} }};", .{ fmtid, pid }, .{ .start = .mid });
        } else {
            try writer.writef("pub const {s} = @import(\"{s}zig.zig\").typedConst(", .{
                name_pool,
                sdk_file.getWin32DirImportPrefix(),
            }, .{ .nl = false });
            try generateTypeRef(sdk_file, writer, zig_type_formatter);
            try writer.writef(", {});", .{
                fmtConstValue(constant.ValueType, constant.Value, sdk_file),
            }, .{ .start = .mid });
        }
    }
}

// workaround https://github.com/microsoft/win32metadata/issues/389
const also_usable_type_api_map = std.StaticStringMap([]const u8).initComptime(.{
    .{ "HDC", "Graphics.Gdi" },
    .{ "HGDIOBJ", "Graphics.Gdi" },
    .{ "HICON", "UI.WindowsAndMessaging" },
    .{ "HANDLE", "System.SystemServices" },
    .{ "HeapHandle", "System.SystemServices" },
    .{ "BCRYPT_HANDLE", "Security.Cryptography" },
});

const Depth = u3;

const CodeWriter = struct {
    writer: BufferedWriter.Writer,
    depth: u4,
    midline: bool,

    pub fn writeBlock(self: CodeWriter, comptime s: []const u8) !void {
        std.debug.assert(s[s.len - 1] == '\n');
        std.debug.assert(self.depth == 0);
        std.debug.assert(!self.midline);
        try self.writer.writeAll(s);
    }

    pub const LineOpt = struct {
        start: enum { line, any, mid } = .line,
        nl: bool = true,
    };
    pub fn writef(self: *CodeWriter, comptime fmt: []const u8, args: anytype, comptime opt: LineOpt) !void {
        std.debug.assert(null == std.mem.indexOf(u8, fmt, "\n"));
        const do_indent = blk: {
            switch (opt.start) {
                .line => {
                    std.debug.assert(!self.midline);
                    break :blk true;
                },
                .any => break :blk !self.midline,
                .mid => {
                    std.debug.assert(self.midline);
                    break :blk false;
                },
            }
        };
        if (do_indent) {
            var i: @TypeOf(self.depth) = 0;
            while (i < self.depth) : (i += 1) {
                try self.writer.writeAll("    ");
            }
            self.midline = true;
        }
        if (@typeInfo(@TypeOf(args)).Struct.fields.len == 0) {
            try self.writer.writeAll(fmt ++ (if (opt.nl) "\n" else ""));
        } else {
            try self.writer.print(fmt ++ (if (opt.nl) "\n" else ""), args);
        }
        self.midline = !opt.nl;
    }

    pub fn write(self: *CodeWriter, comptime s: []const u8, comptime opt: LineOpt) !void {
        try self.writef(s, .{}, opt);
    }
    pub fn line(self: *CodeWriter, comptime s: []const u8) !void {
        try self.writef(s, .{}, .{});
    }
    pub fn linef(self: *CodeWriter, comptime fmt: []const u8, args: anytype) !void {
        try self.writef(fmt, args, .{});
    }
};

pub fn addArchSpecific(
    comptime T: type,
    arch_specific: *ArchSpecificMap(T),
    pool_name: StringPool.Val,
    filter: metadata.Architectures.Filter,
    obj: T,
) !void {
    if (arch_specific.getPtr(pool_name)) |object| {
        object.add(.{ .filter = filter, .obj = obj });
    } else {
        var objects = ArchSpecificObjects(T){};
        objects.object_array[0] = .{ .filter = filter, .obj = obj };
        objects.object_count = 1;
        try arch_specific.put(pool_name, objects);
    }
}

fn generateType(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    arch_specific: *ArchSpecificMap(metadata.Type),
    t: metadata.Type,
    enum_alias_conflicts: *StringPool.HashMap(StringPool.Val),
) !void {
    if (api_type_substitutes.get(t.Name)) |replacement| {
        try writer.linef(
            "// {s} Type '{s}' has been substituted with '{s}'",
            .{ @tagName(t.Kind), t.Name, replacement },
        );
        return;
    }

    try generatePlatformComment(writer, t.Platform);

    switch (t.Kind) {
        .ComClassID => |class_id| {
            if (t.Architectures.filter != null)
                jsonPanicMsg("not impl", .{});
            const clsid_pool = try global_symbol_pool.addFormatted("CLSID_{s}", .{t.Name});
            sdk_file.uses_guid = true;
            try writer.linef("const {s}_Value = Guid.initString(\"{s}\");", .{ clsid_pool, class_id.Guid });
            try writer.linef("pub const {s} = &{0s}_Value;", .{clsid_pool});
            try sdk_file.const_exports.append(clsid_pool);
            return;
        },
        else => {},
    }

    const pool_name = try global_symbol_pool.add(t.Name);

    // TODO: should I be adding this to type_exports if it's arch specific?
    //       type_exports may need to have an ArchFlags for each symbol
    if (t.Architectures.filter == null) {
        std.debug.assert(sdk_file.type_exports.get(pool_name) == null);
    }
    try sdk_file.type_exports.put(pool_name, {});

    if (types_that_conflict_with_consts.get(t.Name)) |_| {
        try writer.line("// WARNING: this type symbol conflicts with a const!");
        try writer.linef("pub const {s}_CONFLICT_ = usize;", .{t.Name});
    } else if (types_that_conflict_with_something.get(t.Name)) |_| {
        try writer.line("// WARNING: this type symbol conflicts with something!");
        try writer.linef("pub const {s}_CONFLICT_ = usize;", .{t.Name});
    } else if (types_to_skip.get(t.Name)) |msg| {
        try writer.linef("// TODO: not generating this type because {s}", .{msg});
        try writer.linef("pub const {s} = usize;", .{t.Name});
    } else if (t.Architectures.filter) |filter| {
        try addArchSpecific(metadata.Type, arch_specific, pool_name, filter, t);
    } else {
        const def_prefix = try std.fmt.allocPrint(allocator, "pub const {p} = ", .{std.zig.fmtId(t.Name)});
        defer allocator.free(def_prefix);
        try generateTypeDefinition(sdk_file, writer, t, enum_alias_conflicts, pool_name, def_prefix, ";");
    }
}

fn generateTypeDefinition(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    t: metadata.Type,
    enum_alias_conflicts: *StringPool.HashMap(StringPool.Val),
    pool_name: StringPool.Val,
    def_prefix: []const u8,
    def_suffix: []const u8,
) !void {
    switch (t.Kind) {
        .NativeTypedef => |typedef| {
            if (typedef.FreeFunc) |free_func| {
                try writer.linef("// TODO: this type has a FreeFunc '{s}', what can Zig do with this information?", .{free_func});
            }
            if (typedef.InvalidHandleValue) |v| {
                try writer.linef("// TODO: this type has an InvalidHandleValue of '{}', what can Zig do with this information?", .{v});
            }

            // HANDLE PSTR and PWSTR specially because win32metadata is not properly declaring them as arrays, only pointers
            // not sure if this is a real issue with the metadata or intentional
            const special: enum { pstr, pwstr, other } = blk: {
                if (std.mem.eql(u8, pool_name.slice, "PSTR")) break :blk .pstr;
                if (std.mem.eql(u8, pool_name.slice, "PWSTR")) break :blk .pwstr;
                break :blk .other;
            };
            if (special == .pstr or special == .pwstr) {
                //
                // verify the definition is what we expect, if not, we might be able to remove out workaround
                //
                const child_generic = switch (typedef.Def) {
                    .PointerTo => |to| to.Child,
                    else => jsonPanicMsg(
                        "definition of {s} has changed! (Def.Kind != PointerTo, it is {s})",
                        .{ t.Name, @tagName(typedef.Def) },
                    ),
                };
                const child_native = switch (child_generic.*) {
                    .Native => |*n| n,
                    else => jsonPanicMsg(
                        "definition of {s} has changed! (Def.Child.Kind != Native, it is {s})",
                        .{ pool_name, @tagName(child_generic.*) },
                    ),
                };
                // TODO: is something is referencing PSTR or PWSTR and is NotNullTerm, then
                //       maybe I'll do something like @import("zig.zig").NotNullTerm(PSTR)
                switch (child_native.Name) {
                    .Byte => {
                        jsonEnforce(special == .pstr);
                        try writer.linef("{s}[*:0]u8{s}", .{ def_prefix, def_suffix });
                    },
                    .Char => {
                        jsonEnforce(special == .pwstr);
                        try writer.linef("{s}[*:0]u16{s}", .{ def_prefix, def_suffix });
                    },
                    else => jsonPanic(),
                }
                return;
            }

            if (typedef.AlsoUsableFor) |also_usable_for| {
                if (also_usable_type_api_map.get(also_usable_for)) |api| {
                    const api_pool = try global_symbol_pool.add(api);
                    try sdk_file.addApiImport(t.Architectures, also_usable_for, api_pool, &.{});
                    try writer.linef("//TODO: type '{s}' is \"AlsoUsableFor\" '{s}' which means this type is implicitly", .{ pool_name, also_usable_for });
                    try writer.linef("//      convertible to '{s}' but not the other way around.  I don't know how to do this", .{also_usable_for});
                    try writer.line("//      in Zig so for now I'm just defining it as an alias");
                    try writer.linef("{s}{s}{s}", .{ def_prefix, also_usable_for, def_suffix });
                    //try writer.linef("{s}extern struct {{ base: {s} }}{s}", .{def_prefix, also_usable_for, def_suffix});
                } else std.debug.panic("AlsoUsableFor type '{s}' is missing from alsoUsableForApiMap", .{also_usable_for});
                return;
            }

            // NOTE: for now, I'm just hardcoding a few types to redirect to the ones defined in 'std'
            //       this allows apps to use values of these types interchangeably with bindings in std
            if (@import("handletypes.zig").std_handle_types.get(pool_name.slice)) |std_sym| {
                try writer.linef("{s}@import(\"std\").{s}{s}", .{ def_prefix, std_sym, def_suffix });
                return;
            }
            // workaround https://github.com/microsoft/win32metadata/issues/395
            if (@import("handletypes.zig").handle_types.get(pool_name.slice)) |_| {
                try writer.linef("{s}*opaque{{}}{s}", .{ def_prefix, def_suffix });
                return;
            }

            // TODO: set is_const, in and out properly
            const zig_type_formatter = try addTypeRefs(
                sdk_file,
                t.Architectures,
                typedef.Def,
                TypeRefFormatter.Options.defaults(.{
                    .reason = .direct_type_access,
                }),
                null,
            );
            try writer.writef("{s}", .{def_prefix}, .{ .nl = false });
            try generateTypeRef(sdk_file, writer, zig_type_formatter);
            try writer.writef("{s}", .{def_suffix}, .{ .start = .mid });
        },
        .Enum => |type_enum| try generateEnum(sdk_file, writer, type_enum, pool_name, enum_alias_conflicts, def_prefix, def_suffix),
        .Struct => try generateStructOrUnion(sdk_file, writer, t, def_prefix, def_suffix, null),
        .Union => try generateStructOrUnion(sdk_file, writer, t, def_prefix, def_suffix, null),
        .ComClassID => @panic("hasn't happened yet?"),
        .Com => |com| try generateCom(sdk_file, writer, t, com, pool_name, def_prefix),
        .FunctionPointer => |func| {
            if (funcPtrHasDependencyLoop(pool_name.slice)) {
                try writer.line("// TODO: this function pointer causes dependency loop problems, so it's stubbed out");
                try writer.linef(
                    "{s}*const fn() callconv(@import(\"std\").os.windows.WINAPI) void{s}",
                    .{ def_prefix, def_suffix },
                );
                return;
            }
            try generateFunction(sdk_file, writer, .{ .ptr = .{
                .t = t,
                .func = func,
                .def_prefix = def_prefix,
                .def_suffix = def_suffix,
            } });
            try sdk_file.tmp_func_ptr_workaround_list.append(pool_name);
        },
    }
}

const api_type_substitutes = std.StaticStringMap([]const u8).initComptime(.{
    // D2D1_COLOR_F is just an alias to D2D_COLOR_F but in the metadata it's
    // a distinct type, we can remove it, the only purpose of having it separate
    // I can think of is to allow overloads, but we don't use overloading.
    .{ "D2D1_COLOR_F", "D2D_COLOR_F" },
});
fn getApiRefSubstitute(type_name: []const u8, parents: []const []const u8) ?[]const u8 {
    const replacement = api_type_substitutes.get(type_name) orelse return null;
    if (parents.len != 0) std.debug.panic(
        "type '{s}' has a replacement '{s}' but also has parents?",
        .{ type_name, replacement },
    );
    return replacement;
}

const types_to_skip = std.StaticStringMap([]const u8).initComptime(.{
    .{ "FILEGROUPDESCRIPTORA", "array of 'win32.ui.shell.FILEDESCRIPTORA' not allowed in packed struct due to padding bits" },
});
const types_that_conflict_with_consts = std.StaticStringMap(void).initComptime(.{
    // This symbol conflicts with a constant with the exact same name
    .{"AE_SRVSTATUS"},
    .{"AE_SESSLOGON"},
    .{"AE_SESSLOGOFF"},
    .{"AE_SESSPWERR"},
    .{"AE_CONNSTART"},
    .{"AE_CONNSTOP"},
    .{"AE_CONNREJ"},
    .{"AE_RESACCESS"},
    .{"AE_RESACCESSREJ"},
    .{"AE_CLOSEFILE"},
    .{"AE_SERVICESTAT"},
    .{"AE_ACLMOD"},
    .{"AE_UASMOD"},
    .{"AE_NETLOGON"},
    .{"AE_NETLOGOFF"},
    .{"AE_LOCKOUT"},
});
const types_that_conflict_with_something = std.StaticStringMap(void).initComptime(.{
    // https://github.com/microsoft/win32metadata/issues/632
    // There's something weird going on with these types.  The types are empty
    // but they are also defined as nested types inside the other types that use them.
    // The reason they must be skipped right now is they are causing name conflict errors
    // becuase they are duplicated.
    .{"DHCP_SUBNET_ELEMENT_UNION"},
    .{"DHCP_OPTION_ELEMENT_UNION"},
    .{"DHCP_OPTION_SCOPE_UNION6"},
    .{"DHCP_CLIENT_SEARCH_UNION"},
    .{"DHCP_SUBNET_ELEMENT_UNION_V4"},
    .{"DHCP_SUBNET_ELEMENT_UNION_V6"},
});

const com_types_to_skip = std.StaticStringMap(void).initComptime(.{
    .{"placeholder_ignore_me"},
});

fn generatePlatformComment(writer: *CodeWriter, maybe_platform: ?metadata.Platform) !void {
    if (maybe_platform) |platform| {
        try writer.linef("// TODO: this type is limited to platform '{s}'", .{@tagName(platform)});
    }
}

const AnonTypes = struct {
    types: StringPool.HashMap(metadata.Type),
    pub fn init() AnonTypes {
        return .{
            .types = StringPool.HashMap(metadata.Type).init(allocator),
        };
    }
    pub fn deinit(self: *AnonTypes) void {
        self.types.deinit();
    }
};

fn generateStructOrUnion(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    t: metadata.Type,
    def_prefix: []const u8,
    def_suffix: []const u8,
    nested_context: ?*const NestedContext,
) !void {
    std.debug.assert(!isAnonymousTypeName(t.Name));
    try writer.writef("{s}", .{def_prefix}, .{ .nl = false });
    try generateStructOrUnionDef(sdk_file, writer, t, nested_context);
    try writer.linef("}}{s}", .{def_suffix});
}

fn generateStructOrUnionDef(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    t: metadata.Type,
    nested_context: ?*const NestedContext,
) anyerror!void {
    const info: struct {
        container: *const metadata.StructOrUnion,
        zig_type: []const u8,
    } = switch (t.Kind) {
        .Struct => |*c| .{ .container = c, .zig_type = "struct" },
        .Union => |*c| .{ .container = c, .zig_type = "union" },
        else => std.debug.panic(
            "invalid type kind '{s}' passed to generateStructOrUnionDef",
            .{@tagName(t.Kind)},
        ),
    };
    const container = info.container;
    const zig_type = info.zig_type;

    try writer.writef("extern {s} {{", .{zig_type}, .{ .start = .any });
    writer.depth += 1;
    defer writer.depth -= 1;

    var anon_types = AnonTypes.init();
    defer anon_types.deinit();

    const this_nested_context_data = NestedContext{
        .nested_types = container.NestedTypes,
        .parent = nested_context,
    };
    const this_nested_context = if (container.NestedTypes.len > 0) &this_nested_context_data else nested_context;

    for (container.NestedTypes) |*nested_type| {
        const pool_name = try global_symbol_pool.add(nested_type.Name);
        if (isAnonymousTypeName(nested_type.Name)) {
            if (nested_type.Architectures.filter) |_| // we don't handle architectures in this case
                jsonPanicMsg("not impl", .{});
            try anon_types.types.put(pool_name, nested_type.*);
        } else {
            // TODO: I don't know why this isn't working!!!
            //const def_prefix = try std.fmt.allocPrint(allocator, "pub const {p} = ", .{std.zig.fmtId(pool_name)});
            //defer allocator.free(def_prefix);
            try writer.writef("pub const {s} = ", .{pool_name}, .{ .nl = false });
            switch (nested_type.Kind) {
                .Union => try generateStructOrUnionDef(sdk_file, writer, nested_type.*, this_nested_context),
                .Struct => try generateStructOrUnionDef(sdk_file, writer, nested_type.*, this_nested_context),
                else => jsonPanicMsg("not impl", .{}),
            }
            try writer.line("};");
        }
    }

    if (container.Fields.len == 0) {
        try writer.line("placeholder: usize, // TODO: why is this type empty?");
    } else {
        for (container.Fields) |*field| {
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // TODO: implement null_modifier
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            const field_options = TypeRefFormatter.Options.defaults(.{
                .reason = .var_decl,
                .is_const = field.Attrs.Const,
                .optional = field.Attrs.Optional,
                .not_null_term = field.Attrs.NotNullTerminated,
                .null_null_term = field.Attrs.NullNullTerminated,
                .anon_types = &anon_types,
                .extra_mod = .{},
            });
            if (field.Attrs.Obselete) {
                try writer.line("/// Deprecated");
            }
            const field_type_formatter = try addTypeRefs(sdk_file, t.Architectures, field.Type, field_options, this_nested_context);
            try writer.writef("{p}: ", .{std.zig.fmtId(field.Name)}, .{ .nl = false });
            try generateTypeRef(sdk_file, writer, field_type_formatter);
            if (container.PackingSize >= 1) {
                try writer.writef(" align({})", .{container.PackingSize}, .{ .start = .mid, .nl = false });
            }
            try writer.write(",", .{ .start = .mid });
        }
    }
}

// Not sure whether enums should be exhaustive or not, for now
// I'll default to all of them being exhaustive except the ones
// in this list that I know are currently not exhaustive.
const non_exhaustive_enums = std.StaticStringMap(void).initComptime(.{
    .{"WIN32_ERROR"},
    // This enum is not exhaustive because it is missing a value, see
    //     https://github.com/microsoft/win32metadata/issues/203
    .{"CLSCTX"},
    // SEND_FLAGS is missing the value 0
    .{"SEND_FLAGS"},
    .{"WINDOW_LONG_PTR_INDEX"},
});

fn shortEnumValueName(enum_type_name: []const u8, full_value_name: []const u8) []const u8 {
    if (full_value_name.len == 0) {
        // NOTE: this is probably a bug in the win32metadata
        return "_noname_";
    }
    const offset = init: {
        if ((full_value_name.len <= enum_type_name.len + 1) or
            (full_value_name[enum_type_name.len] != '_') or
            !std.mem.startsWith(u8, full_value_name, enum_type_name))
        {
            break :init 0;
        }
        const first_c = full_value_name[enum_type_name.len + 1];
        if (first_c <= '9' and first_c >= '0') {
            break :init enum_type_name.len;
        }
        break :init enum_type_name.len + 1;
    };
    return full_value_name[offset..];
}

// TODO: this is a set of enums whose value symbols conflict with other symbols
const suppress_enum_aliases = blk: {
    @setEvalBranchQuota(3000);
    break :blk std.StaticStringMap(void).initComptime(.{

        // suppress this one because the CFE_UNDERLINE enum value alias conflicts with the name of an enum type
        .{"CFE_EFFECTS"},
        // these types have values that conflict with their own enum type name
        .{"INTERNET_DEFAULT_PORT"},
        .{"PDH_VERSION"},
        .{"POWER_PLATFORM_ROLE_VERSION"},
        // --------------------------------------------------------------------------------
        // suppress these enum value aliases because there is already a constant with the same name
        // --------------------------------------------------------------------------------
        .{"JsRuntimeVersion"},
        .{"GetIconInfo_hicon"},
        .{"PFN_WdsCliCallback_dwMessageIdFlags"},
        .{"MIB_IPFORWARD_TYPE"},
        .{"OLEMISC"},
        .{"IMAGEHLP_CBA_EVENT_SEVERITY"},
        .{"PFN_WDS_CLI_CALLBACK_MESSAGE_ID"},
        // --------------------------------------------------------------------------------
        // suppress the rest because there is another enum with the same enum value alias
        // --------------------------------------------------------------------------------
        // Security
        .{"NCrypt_dwFlags"},
        .{"IAzClientContext3_GetGroups_ulOptionsFlags"},
        .{"NCryptNotifyChangeKey_dwFlags"},
        .{"SECPKG_ATTR_1"},
        .{"CryptImportPKCS8_dwFlags"},
        .{"NCryptDecrypt_dwFlags"},
        .{"KERB_CERTIFICATE_LOGON_MessageTypeFlags"},
        .{"SC_ACTION_TypeFlags"},
        .{"IIdentityProvider_Advise_dwIdentityUpdateEventsFlags"},
        .{"CRYPT_KEY_PROV_FLAGS"},
        // WindowsProgramming
        .{"VER_MASK"},
        .{"SetHandleInformation_dwFlags"},
        .{"DuplicateHandle_dwOptionsFlags"},
        .{"REG_OPEN_CREATE_OPTIONS"},
        // SystemServices
        .{"QueryInformationJobObject_JobObjectInformationClassFlags"},
        .{"HeapSetInformation_HeapInformationClassFlags"},
        .{"JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_IoRateControlToleranceInterval"},
        .{"JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL"},
        .{"JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_RateControlTolerance"},
        .{"JOBOBJECT_IO_RATE_CONTROL_INFORMATIONFlags"},
        .{"CreateFileMapping_flProtect"},
        .{"PFM_FLAGS"},
        .{"JOBOBJECT_BASIC_LIMIT_INFORMATIONFlags"},
        .{"JOBOBJECT_SECURITY_LIMIT_INFORMATIONFlags"},
        .{"JOBOBJECT_BASIC_UI_RESTRICTIONS_UIRestrictionsClassFlags"},
        // NetManagement
        .{"NetWkstaSetInfo_levelFlags"},
        // ComponentServices
        .{"ICOMAdminCatalog2_IsSafeToDelete_pCOMAdminInUseFlags"},
        .{"ImportUnconfiguredComponents_pVarComponentType"},
        .{"ICOMAdminCatalog_InstallApplication_lOptionsFlags"},
        .{"ICOMAdminCatalog_ExportApplication_lOptionsFlags"},
        .{"WerRegisterFile_regFileTypeFlags"},
        .{"WerReportSubmit_pSubmitResultFlags"},
        .{"WerReportCreate_repTypeFlags"},
        .{"WerReportSubmit_consentFlags"},
        // FileSystem
        .{"DefineDosDevice_dwFlags"},
        .{"CreateFile_dwShareMode"},
        .{"CreateLogFile_fCreateDispositionFlags"},
        .{"ReOpenFile_dwFlagsAndAttributes"},
        // Parental Controls
        .{"IWindowsParentalControlsCore_GetVisibility_peVisibilityFlags"},
        .{"GetRestrictions_pdwRestrictions"},
        .{"IWPCWebSettings_GetSettings_pdwSettingsFlags"},
        // Gdi
        .{"CombineRgn_iMode"},
        .{"CreateDIBitmap_iUsage"},
        .{"PatBlt_ropFlags"},
        .{"GetCurrentObject_typeFlags"},
        .{"SetROP2_rop2Flags"},
        // MachineLearning
        .{"MLOperatorTensorDataType"},
        .{"MLOperatorExecutionType"},
        .{"MLOperatorEdgeType"},
        // Com
        .{"IPropertyPageSite_OnStatusChangeFlags"},
        .{"IOleControlSite_TransformCoordsFlags"},
        // ApplicationInstallationAndServicing
        .{"LPDISPLAYVAL_uiTypeFlags"},
        .{"MsiSourceList_dwContext"},
        .{"MsiAdvertiseScript_dwFlags"},
        .{"MsiViewModify_eModifyModeFlags"},
        .{"MsiCreateTransformSummaryInfo_iErrorConditions"},
        .{"MsiCreateTransformSummaryInfo_iValidation"},
        .{"MsiEnumClientsEx_dwContext"},
        // WindowsAndMessaging
        .{"DrawIconEx_diFlags"},
        // Debug
        .{"SymGetHomeDirectory_type"},
        .{"SymGetSymbolFile_Type"},
        // Multimedia
        .{"MIDI_OPEN_TYPE"},
    });
};

const EnumValue = struct {
    pool_name: StringPool.Val,
    short_name: []const u8,
    value: std.json.Value,
    no_alias: bool,
    conflict_index: ?usize,
    pub fn valueIsZero(self: EnumValue) bool {
        return switch (self.value) {
            .integer => |i| i == 0,
            else => false,
        };
    }

    pub const FlagsValue = union(enum) {
        zero: void,
        flag: u8,
        mask: i64,
    };
    pub fn flagsValue(self: EnumValue) FlagsValue {
        switch (self.value) {
            .integer => |i| {
                if (i == 0) return .zero;

                var index: u6 = 0;
                while (true) : (index += 1) {
                    if ((@as(i64, 1) << index) == i) return .{ .flag = index };
                    if (index == 63) break;
                }

                return .{ .mask = i };
            },
            .number_string => |s| {
                if (std.mem.eql(u8, s, "9223372036854775808"))
                    return .{ .flag = 63 }; // TODO: verify this is not off-by-one
                std.debug.panic(
                    "todo: handle enum flag value json number string '{s}' ('{s}' '{s}')",
                    .{ s, self.pool_name, self.short_name },
                );
            },
            else => {
                std.debug.panic("todo: flagIndex for json value {s}", .{@tagName(self.value)});
            },
        }
    }
};
fn matchLen(a: []const u8, b: []const u8) usize {
    var i: usize = 0;
    while (i < a.len and i < b.len and a[i] == b[i]) : (i += 1) {}
    return i;
}
fn setShortNames(values: []EnumValue) void {
    var at_first = true;
    var longest_prefix_match: []const u8 = undefined;
    for (values) |*val_ref| {
        if ((val_ref.pool_name.eql(global_symbol_none) or
            val_ref.pool_name.eql(global_symbol_None)) and
            val_ref.valueIsZero())
        {
            val_ref.short_name = val_ref.pool_name.slice;
            val_ref.no_alias = true;
            continue;
        }

        if (at_first) {
            longest_prefix_match = val_ref.pool_name.slice;
            at_first = false;
        } else {
            longest_prefix_match.len = matchLen(longest_prefix_match, val_ref.pool_name.slice);
        }
    }
    for (values) |*val_ref| {
        if (val_ref.no_alias)
            continue;

        if (val_ref.pool_name.slice.len == 0) {
            // TODO: this happens to snmp:AS_ANY_TYPE, it's probably a bug that should be filed
            val_ref.short_name = "__no_name__";
        } else {
            var cutoff = longest_prefix_match.len;
            if (cutoff > 0 and cutoff == val_ref.pool_name.slice.len) {
                cutoff -= 1;
            }
            val_ref.short_name = val_ref.pool_name.slice[cutoff..];
        }
    }
}

fn generateEnum(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    type_enum: metadata.Type.Enum,
    pool_name: StringPool.Val,
    enum_alias_conflicts: *StringPool.HashMap(StringPool.Val),
    def_prefix: []const u8,
    def_suffix: []const u8,
) !void {
    const integer_base = zigTypeFromIntegerBase(type_enum.IntegerBase);

    const values = try allocator.alloc(EnumValue, type_enum.Values.len);
    var values_initialized_len: usize = 0;
    defer allocator.free(values);
    for (type_enum.Values) |*enum_field| {
        values[values_initialized_len] = .{
            .pool_name = try global_symbol_pool.add(enum_field.Name),
            .short_name = "",
            .value = enum_field.Value,
            .no_alias = false,
            .conflict_index = null,
        };
        values_initialized_len += 1;
    }
    setShortNames(values);

    // find conflicts
    for (values, 0..) |val, i| {
        for (values[0..i], 0..) |other_val, j| {
            if (jsonEql(val.value, other_val.value)) {
                values[i].conflict_index = j;
                break;
            }
        }
    }
    var flag_map = [1]?*EnumValue{null} ** 64;

    const enum_type = if (type_enum.Flags) "packed struct" else "enum";

    try writer.linef("{s}{s}({s}) {{", .{ def_prefix, enum_type, integer_base });
    if (values.len == 0) {
        // zig doesn't allow empty enums
        try writer.line("    _");
    } else if (!type_enum.Flags) {
        for (values) |val| {
            if (val.conflict_index) |conflict_index| {
                try writer.linef("    // {p} = {}, this enum value conflicts with {p}", .{ std.zig.fmtId(val.short_name), fmtJson(val.value), std.zig.fmtId(values[conflict_index].short_name) });
            } else {
                try writer.linef("    {p} = {},", .{ std.zig.fmtId(val.short_name), fmtJson(val.value) });
            }
        }
        if (non_exhaustive_enums.get(pool_name.slice)) |_| {
            writer.depth += 1;
            defer writer.depth -= 1;
            try writer.linef("_,", .{});
            try writer.linef("pub fn tagName(self: {s}) ?[:0]const u8 {{", .{pool_name});
            try writer.line("    return switch (self) {");
            for (values) |val| {
                if (val.conflict_index) |_| continue;
                try writer.linef("        .{p} => \"{}\",", .{
                    std.zig.fmtId(val.short_name),
                    std.zig.fmtEscapes(val.short_name),
                });
            }
            try writer.line("        else => null,");
            try writer.line("    };");
            try writer.line("}");
            try writer.linef("pub fn fmt(self: {s}) Fmt {{ return .{{ .value = self }}; }}", .{pool_name});
            try writer.line("pub const Fmt = struct {");
            try writer.linef("    value: {s},", .{pool_name});
            try writer.line("    pub fn format(");
            try writer.line("        self: Fmt,");
            try writer.line("        comptime fmt_spec: []const u8,");
            try writer.line("        options: @import(\"std\").fmt.FormatOptions,");
            try writer.line("        writer: anytype,");
            try writer.line("    ) !void {");
            try writer.line("        _ = fmt_spec;");
            try writer.line("        _ = options;");
            try writer.line("        try writer.print(\"{s}({})\", .{self.value.tagName() orelse \"?\", @intFromEnum(self.value)});");
            try writer.line("    }");
            try writer.line("};");
        }
    }
    if (type_enum.Flags) {
        for (values) |*val| {
            if (val.conflict_index) |_| continue;
            switch (val.flagsValue()) {
                .zero => {},
                .flag => |index| {
                    // should have had a conflict_index
                    std.debug.assert(flag_map[index] == null);
                    flag_map[index] = val;
                },
                .mask => {},
            }
        }

        const bit_count: usize = blk: {
            if (std.mem.eql(u8, integer_base, "u16")) break :blk 16;
            if (std.mem.eql(u8, integer_base, "i32")) break :blk 32;
            if (std.mem.eql(u8, integer_base, "u32")) break :blk 32;
            if (std.mem.eql(u8, integer_base, "u64")) break :blk 64;
            std.debug.panic("todo: handle integer base '{s}'", .{integer_base});
        };
        for (flag_map[0..bit_count], 0..) |maybe_flag, i| {
            const flag = maybe_flag orelse {
                try writer.linef("    _{}: u1 = 0,", .{i});
                continue;
            };
            try writer.linef("    {p}: u1 = 0,", .{std.zig.fmtId(flag.short_name)});
        }
        for (flag_map[bit_count..]) |maybe_flag| {
            if (maybe_flag) |_|
                jsonPanicMsg("enum value is out-of-range for this flag integer base type", .{});
        }

        // print any flags (only 1-bit values) that had conflicts
        for (values) |*val| {
            switch (val.flagsValue()) {
                .zero => {},
                .flag => |index| {
                    if (val.conflict_index) |conflict_index| {
                        try writer.linef("    // {p} (bit index {}) conflicts with {p}", .{
                            std.zig.fmtId(val.short_name),
                            index,
                            std.zig.fmtId(values[conflict_index].short_name),
                        });
                    }
                },
                .mask => {},
            }
        }
    }
    try writer.linef("}}{s}", .{def_suffix});

    if (std.mem.eql(u8, def_suffix, ",")) {
        @panic("can't generate arch-specific enum aliases right now");
    }
    std.debug.assert(std.mem.eql(u8, def_suffix, ";"));

    if (type_enum.Scoped) {
        try writer.linef("// NOTE: not creating aliases because this enum is 'Scoped'", .{});
        return;
    }
    if (suppress_enum_aliases.get(pool_name.slice)) |_| {
        try writer.linef("// TODO: enum '{}' has known issues with its value aliases", .{pool_name});
        return;
    }

    // create value aliases
    var alias_count: u32 = 0;
    for (values) |val| {
        if (enum_alias_conflicts.get(val.pool_name)) |existing| {
            std.debug.print("error: enum value alias '{}' is defined by 2 enum types.\n", .{val.pool_name});
            std.debug.print("       add one of the following lines to the suppress_enum_aliases list:\n", .{});
            std.debug.print("    .{{ \"{}\", .{{}} }},\n", .{existing});
            std.debug.print("    .{{ \"{}\", .{{}} }},\n", .{pool_name});
            std.process.exit(0xff);
        }
        if (val.no_alias) {
            continue;
        }
        alias_count += 1;
        try enum_alias_conflicts.put(val.pool_name, pool_name);
        try sdk_file.const_exports.append(val.pool_name);
        const target_short_name = if (val.conflict_index) |i| values[i].short_name else val.short_name;
        if (type_enum.Flags) switch (val.flagsValue()) {
            .zero => try writer.linef("pub const {} = {}{{ }};", .{ val.pool_name, pool_name }),
            .flag => try writer.linef("pub const {} = {}{{ .{p} = 1 }};", .{ val.pool_name, pool_name, std.zig.fmtId(target_short_name) }),
            .mask => |mask| {
                try writer.linef("pub const {} = {}{{", .{ val.pool_name, pool_name });
                var mask_left = mask;
                var index: u6 = 0;
                while (true) : (index += 1) {
                    const next_flag_bit: i64 = (@as(i64, 1) << index);
                    if (0 != (next_flag_bit & mask)) {
                        if (flag_map[index]) |flag| {
                            const flag_target_short_name = if (flag.conflict_index) |i| values[i].short_name else flag.short_name;
                            try writer.linef("    .{p} = 1,", .{std.zig.fmtId(flag_target_short_name)});
                        } else {
                            try writer.linef("    ._{} = 1,", .{index});
                        }
                        mask_left &= ~next_flag_bit;
                    }
                    if (mask_left == 0) break;
                }
                try writer.line("};");
            },
        } else {
            try writer.linef("pub const {} = {}.{p};", .{ val.pool_name, pool_name, std.zig.fmtId(target_short_name) });
        }
    }
}

fn getComInterface(api: []const u8, name: []const u8) ?metadata.TypeRef {
    const pass1_api_map = global_pass1.get(api) orelse jsonPanicMsg("com interface inside unknown api '{s}'", .{api});
    const pass1_type = pass1_api_map.get(name) orelse jsonPanicMsg(
        "com interface '{s}' does not exist in api '{s}'",
        .{ name, api },
    );
    return switch (pass1_type) {
        .Com => |com| com.Interface,
        else => jsonPanic(),
    };
}

fn generateCom(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    t: metadata.Type,
    type_com: metadata.Com,
    com_pool_name: StringPool.Val,
    def_prefix: []const u8,
) !void {
    if (type_com.Attrs.Agile) {
        try writer.line("// This COM type is Agile, not sure what that means");
    }
    const skip = com_types_to_skip.has(t.Name);
    if (skip) {
        try writer.line("// WARNING: this COM type has been skipped because it causes some sort of error");
    }

    const iid_pool = try global_symbol_pool.addFormatted("IID_{s}", .{com_pool_name.slice});
    if (type_com.Guid) |guid| {
        sdk_file.uses_guid = true;
        try writer.linef("const {s}_Value = Guid.initString(\"{s}\");", .{ iid_pool, guid });
        try writer.linef("pub const {s} = &{0s}_Value;", .{iid_pool});
        try sdk_file.const_exports.append(iid_pool);
    }

    try writer.linef("{s}extern union {{", .{def_prefix});
    try writer.line("    pub const VTable = extern struct {");
    var maybe_iface_formatter: ?TypeRefFormatter = null;

    const maybe_overloads: ?ComMethodMap = if (sdk_file.com_type_overloads) |m| m.get(com_pool_name.slice) else null;

    {
        const ComSymbolState = enum { unique, conflicts };
        var method_set = StringHashMap(ComSymbolState).init(allocator);
        defer method_set.deinit();

        for (type_com.Methods) |*method| {
            const entry = try method_set.getOrPut(method.Name);
            if (entry.found_existing) {
                entry.value_ptr.* = .conflicts;
            } else {
                entry.value_ptr.* = .unique;
            }
        }

        const count_before = global_missing_com_overloads.items.len;
        for (type_com.Methods, 0..) |*method, method_index| {
            const maybe_overload_suffixes: ?ComSuffixMap = if (maybe_overloads) |o|
                o.get(method.Name)
            else
                null;
            const state = method_set.get(method.Name).?;
            switch (state) {
                .unique => {
                    if (maybe_overload_suffixes) |_| fatal(
                        "api '{s}' COM type '{s}' method '{s}' has a unique name but also entries in ComOverloads.txt?",
                        .{ sdk_file.json_name, com_pool_name, method.Name },
                    );
                },
                .conflicts => {
                    const have_overload = blk: {
                        const overload_suffixes = maybe_overload_suffixes orelse break :blk false;
                        const suffix = overload_suffixes.get(@intCast(method_index)) orelse break :blk false;
                        std.debug.assert(suffix.len > 0);
                        break :blk true;
                    };
                    if (!have_overload) {
                        try global_missing_com_overloads.append(allocator, .{
                            .api = sdk_file.json_name,
                            .com_type = com_pool_name.slice,
                            .method = try allocator.dupe(u8, method.Name),
                            .method_index = @intCast(method_index),
                        });
                    }
                },
            }
        }
        if (count_before != global_missing_com_overloads.items.len)
            return;
    }

    if (skip) {
        try writer.line("        _: *opaque{}, // just a placeholder because this COM type is skipped");
    } else {
        if (type_com.Interface) |iface| {
            maybe_iface_formatter = try addTypeRefs(sdk_file, t.Architectures, iface, TypeRefFormatter.Options.defaults(.{
                .reason = .direct_type_access,
            }), null);
            try writer.write("        base: ", .{ .nl = false });
            try generateTypeRef(sdk_file, writer, maybe_iface_formatter.?);
            try writer.write(".VTable,", .{ .start = .mid });
        }

        for (type_com.Methods, 0..) |*method, method_index| {
            writer.depth += 2;

            const suffix: []const u8 = blk: {
                const overload = maybe_overloads orelse break :blk "";
                const suffixes = overload.get(method.Name) orelse break :blk "";
                break :blk suffixes.get(@intCast(method_index)) orelse fatal(
                    "method '{s}' is missing suffix for method at index {}",
                    .{ method.Name, method_index },
                );
            };

            var zig_name_buf: [100]u8 = undefined;
            const zig_name = try std.fmt.bufPrint(
                &zig_name_buf,
                "{s}{s}",
                .{ method.Name, suffix },
            );

            try generateFunction(sdk_file, writer, .{ .com = .{
                .method = method,
                .type_name = com_pool_name.slice,
                .zig_name = zig_name,
            } });
            writer.depth -= 2;
        }
    }

    try writer.line("    };");
    try writer.linef("    vtable: *const VTable,", .{});

    if (type_com.Interface) |direct_iface| {
        var next_iface: metadata.TypeRef = direct_iface;
        var next_iface_com = common.getComInterface(next_iface);
        while (true) {
            const iface_formatter = try addTypeRefs(sdk_file, t.Architectures, next_iface, TypeRefFormatter.Options.defaults(.{
                .reason = .direct_type_access,
            }), null);

            try writer.write("    ", .{ .nl = false });
            try generateTypeRef(sdk_file, writer, iface_formatter);
            try writer.write(": ", .{ .start = .mid, .nl = false });
            try generateTypeRef(sdk_file, writer, iface_formatter);
            try writer.write(",", .{ .start = .mid });

            next_iface = getComInterface(next_iface_com.api, next_iface_com.name) orelse break;
            next_iface_com = common.getComInterface(next_iface);
        }
    }

    try generateComMethods(
        sdk_file,
        writer,
        t.Architectures,
        com_pool_name.slice,
        type_com.Methods,
        maybe_overloads,
    );
    try writer.line("};");
}

fn generateComMethods(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    arches: metadata.Architectures,
    com_type_name: []const u8,
    com_methods: []const metadata.ComMethod,
    maybe_overloads: ?ComMethodMap,
) !void {
    if (maybe_overloads) |overloads| {
        var overload_it = overloads.iterator();
        while (overload_it.next()) |overload_entry| {
            const name = overload_entry.key_ptr.*;
            try writer.writef(
                "    pub const {s} = @compileError(\"COM method '{0s}' must be called using one of the following overload names:",
                .{name},
                .{ .nl = false },
            );
            var suffix_it = overload_entry.value_ptr.iterator();
            var sep: []const u8 = "";
            while (suffix_it.next()) |suffix_entry| {
                const suffix = suffix_entry.value_ptr.*;
                try writer.writef("{s} {s}{s}", .{ sep, name, suffix }, .{ .start = .mid, .nl = false });
                sep = ",";
            }
            try writer.write("\");", .{ .start = .mid });
        }
    }

    for (com_methods, 0..) |*method, method_index| {
        try writer.write("    pub fn ", .{ .nl = false });

        const config_name = getComMethodConfigName(com_type_name, method);
        const modifier_set = getFuncModifiers(sdk_file, config_name, method.Params);

        const suffix: []const u8 = blk: {
            const overload = maybe_overloads orelse break :blk "";
            const suffixes = overload.get(method.Name) orelse break :blk "";
            break :blk suffixes.get(@intCast(method_index)) orelse fatal(
                "method '{s}' is missing suffix for method at index {}",
                .{ method.Name, method_index },
            );
        };

        var method_name_buf: [100]u8 = undefined;
        const method_name = try std.fmt.bufPrint(
            &method_name_buf,
            "{s}{s}",
            .{ method.Name, suffix },
        );
        try writer.writef("{}", .{
            fmtComMethodId(method_name, sdk_file.method_conflict_map),
        }, .{ .start = .mid, .nl = false });
        try writer.writef("(self: *const {s}", .{com_type_name}, .{ .start = .mid, .nl = false });
        for (method.Params, 0..) |*param, param_index| {
            const modifiers = modifier_set.params[param_index];

            const param_options = TypeRefFormatter.Options.fromParamAttrs(param.Attrs, .var_decl, modifiers);
            // NOTE: don't need to call addTypeRefs because it was already called in generateFunction above
            const param_type_formatter = fmtTypeRef(param.Type, arches, param_options, null);
            if (param_options.optional_bytes_param_index) |bytes_param_index| {
                _ = bytes_param_index; // NOTE: can't print this because we are currently inline
                //try writer.linef("// TODO: what to do with BytesParamIndex {}?", .{bytes_param_index});
            }
            try writer.writef(", {s}: ", .{fmtParamId(param.Name, sdk_file.param_conflict_map)}, .{ .start = .mid, .nl = false });
            try generateTypeRef(sdk_file, writer, param_type_formatter);
        }
        // NOTE: don't need to call addTypeRefs because it was already called in generateFunction above
        // TODO: set is_const, in and out properly
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // TODO: set null_modifier properly
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        const return_type_formatter = fmtTypeRef(
            method.ReturnType,
            arches,
            TypeRefFormatter.Options.fromParamAttrs(method.ReturnAttrs, .var_decl, modifier_set.ret),
            null,
        );
        try writer.write(") callconv(.Inline) ", .{ .start = .mid, .nl = false });
        try generateTypeRef(sdk_file, writer, return_type_formatter);
        try writer.write(" {", .{ .start = .mid });
        try writer.write("        return ", .{ .nl = false });
        try writer.writef(
            "self.vtable.{}(self",
            .{fmtComMethodId(method_name, sdk_file.method_conflict_map)},
            .{ .start = .mid, .nl = false },
        );
        for (method.Params) |*param| {
            try writer.writef(", {s}", .{fmtParamId(param.Name, sdk_file.param_conflict_map)}, .{ .start = .mid, .nl = false });
        }
        try writer.write(");", .{ .start = .any });
        try writer.line("    }");
    }
}

// Skip these function pointers to workaround: https://github.com/ziglang/zig/issues/4476
fn funcPtrHasDependencyLoop(name: []const u8) bool {
    if (func_ptr_dependency_loop_problems.get(name)) |_| return true;
    if (std.mem.startsWith(u8, name, "PFN_")) return std.mem.startsWith(u8, name, "PFN_CPD_") or std.mem.startsWith(u8, name, "PFN_PROVIDER_") or std.mem.startsWith(u8, name, "PFN_PROVUI_");
    if (std.mem.startsWith(u8, name, "PIBIO_")) return std.mem.startsWith(u8, name, "PIBIO_SENSOR_") or std.mem.startsWith(u8, name, "PIBIO_ENGINE_") or std.mem.startsWith(u8, name, "PIBIO_STORAGE_") or std.mem.startsWith(u8, name, "PIBIO_FRAMEWORK_");
    if (std.mem.startsWith(u8, name, "LPDDHAL")) return std.mem.startsWith(u8, name, "LPDDHAL_") or std.mem.startsWith(u8, name, "LPDDHALSURFCB_") or std.mem.startsWith(u8, name, "LPDDHALPALCB_") or std.mem.startsWith(u8, name, "LPDDHALVPORTCB_") or std.mem.startsWith(u8, name, "LPDDHALCOLORCB_") or std.mem.startsWith(u8, name, "LPDDHALMOCOMPCB_");
    return std.mem.startsWith(u8, name, "UText") or std.mem.startsWith(u8, name, "UCharIterator");
}
const func_ptr_dependency_loop_problems = std.StaticStringMap(void).initComptime(.{
    .{"FREEOBJPROC"},
    .{"LPEXCEPFINO_DEFERRED_FILLIN"},
    .{"LPDDENUMSURFACESCALLBACK"},
    .{"LPDDENUMSURFACESCALLBACK2"},
    .{"LPDDENUMSURFACESCALLBACK7"},
    .{"OEMCUIPCALLBACK"},
    .{"PAudioStateMonitorCallback"},
    .{"PFN_IO_COMPLETION"},
    .{"PFN_RPCNOTIFICATION_ROUTINE"},
    .{"PFNFILLTEXTBUFFER"},
    .{"WSD_STUB_FUNCTION"},
    .{"PWSD_SOAP_MESSAGE_HANDLER"},
    .{"WS_ASYNC_FUNCTION"},
    .{"CALLERRELEASE"},
    .{"PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK"},
    .{"MI_MethodDecl_Invoke"},
    .{"MI_ProviderFT_GetInstance"},
    .{"MI_ProviderFT_CreateInstance"},
    .{"MI_ProviderFT_ModifyInstance"},
    .{"MI_ProviderFT_DeleteInstance"},
    .{"MI_ProviderFT_AssociatorInstances"},
    .{"MI_ProviderFT_ReferenceInstances"},
    .{"MI_ProviderFT_Invoke"},
    .{"PCMSCALLBACKW"},
    .{"PCMSCALLBACKA"},
    .{"PEVENT_TRACE_BUFFER_CALLBACKW"},
    .{"PEVENT_TRACE_BUFFER_CALLBACKA"},
    .{"EXPR_EVAL"},
    .{"XMIT_HELPER_ROUTINE"},
});

const dll_funcs_with_issues = std.StaticStringMap(void).initComptime(.{
    // These functions don't work yet because Zig doesn't support the 16-byte Guid struct in the C ABI yet
    // See: https://github.com/ziglang/zig/issues/1481
    .{"CorePrinterDriverInstalledA"},
    .{"CorePrinterDriverInstalledW"},
    // workaround https://github.com/microsoft/win32metadata/issues/520
    .{"AuthzInitializeResourceManagerEx"},
    // The 3rd parameter "ObjectType" is "Optional" but is typed as an enum?
    // but the docs says it's a pointer?? wtf is going on with this one?
    .{"BuildTrusteeWithObjectsAndNameA"},
    .{"BuildTrusteeWithObjectsAndNameW"},
    // these functions contain invalid optional types (https://github.com/microsoft/win32metadata/issues/519)
    .{"NCryptOpenKey"},
    .{"NCryptTranslateHandle"},
    .{"CryptSignAndEncodeCertificate"},
    .{"MFPCreateMediaPlayer"},
    .{"QOSRemoveSocketFromFlow"},
    .{"PrjUpdateFileIfNeeded"},
    .{"PrjDeleteFile"},
    .{"JetSetSystemParameterA"},
    .{"JetSetSystemParameterW"},
    .{"MsiGetComponentPathExA"},
    .{"MsiGetComponentPathExW"},
    .{"SymLoadModuleEx"},
    .{"SymLoadModuleExW"},
    .{"PssDuplicateSnapshot"},
});

const ArchCaseContext = enum { outside_arch_case, inside_arch_case };

const ConflictSuffix = struct {
    conflict_count: u8,
    pub fn format(
        self: ConflictSuffix,
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        _ = fmt;
        _ = options;
        if (self.conflict_count > 0) {
            try writer.print("{}", .{self.conflict_count});
        }
    }
};

fn generateArchPrefix(
    writer: *CodeWriter,
    module_depth: u2,
    arches_filter: metadata.Architectures.Filter,
    prefix: []const u8,
) !void {
    try writer.linef("{s}usingnamespace switch (@import(\"{s}zig.zig\").arch) {{", .{ prefix, import_prefix_table[module_depth] });

    var buf: [40]u8 = undefined;
    const case_prefix = buf[0..try formatArchesCase(arches_filter, &buf)];
    try writer.linef("{s}struct {{", .{case_prefix});
    try writer.line("");
}
fn generateArchSuffix(writer: *CodeWriter) void {
    writer.line("") catch @panic("here");
    writer.line("}, else => struct { } };") catch @panic("here");
}

const ParamModifierSet = struct {
    const max_params = 30;
    ret: extra.TypeModifier = .{},
    params: [max_params]extra.TypeModifier = [_]extra.TypeModifier{.{}} ** max_params,
};

fn findParam(
    params: []const metadata.Param,
    name: []const u8,
) ?usize {
    for (params, 0..) |*param, i| {
        if (std.mem.eql(u8, param.Name, name))
            return i;
    }
    return null;
}

fn getComMethodConfigName(type_name: []const u8, method: *const metadata.ComMethod) StringPool.Val {
    var name_buf: [200]u8 = undefined;
    const name = std.fmt.bufPrint(&name_buf, "{s}.{s}", .{ type_name, method.Name }) catch @panic(
        "name_buf not big enough",
    );
    return global_symbol_pool.add(name) catch |e| oom(e);
}

const Function = union(enum) {
    dll: metadata.Function,
    com: struct {
        method: *const metadata.ComMethod,
        type_name: []const u8,
        // will differ from method.Name if it's been modified
        // with an overload suffix
        zig_name: []const u8,
    },
    ptr: struct {
        t: metadata.Type,
        func: metadata.FunctionPointer,
        def_prefix: []const u8,
        def_suffix: []const u8,
    },

    // The name of the function when it's referred to in our configuration
    // such as extra.txt
    pub fn ConfigName(self: Function) StringPool.Val {
        return switch (self) {
            .dll => |dll| global_symbol_pool.add(dll.Name) catch |e| oom(e),
            .com => |com| return getComMethodConfigName(com.type_name, com.method),
            .ptr => |ptr| global_symbol_pool.add(ptr.t.Name) catch |e| oom(e),
        };
    }

    pub fn ReturnType(self: Function) metadata.TypeRef {
        return switch (self) {
            .dll => |dll| dll.ReturnType,
            .com => |com| com.method.ReturnType,
            .ptr => |ptr| ptr.func.ReturnType,
        };
    }
    pub fn ReturnAttrs(self: Function) metadata.ParamAttrs {
        return switch (self) {
            .dll => |dll| dll.ReturnAttrs,
            .com => |com| com.method.ReturnAttrs,
            .ptr => |ptr| ptr.func.ReturnAttrs,
        };
    }
    pub fn Architectures(self: Function) metadata.Architectures {
        return switch (self) {
            .dll => |dll| dll.Architectures,
            .com => |com| com.method.Architectures,
            .ptr => |ptr| ptr.t.Architectures,
        };
    }
    pub fn Platform(self: Function) ?metadata.Platform {
        return switch (self) {
            .dll => |dll| dll.Platform,
            .com => |com| com.method.Platform,
            .ptr => null,
        };
    }
    pub fn Attrs(self: Function) metadata.FunctionAttrs {
        return switch (self) {
            .dll => |dll| dll.Attrs,
            .com => |com| com.method.Attrs,
            .ptr => |ptr| ptr.func.Attrs,
        };
    }
    pub fn Params(self: Function) []const metadata.Param {
        return switch (self) {
            .dll => |dll| dll.Params,
            .com => |com| com.method.Params,
            .ptr => |ptr| ptr.func.Params,
        };
    }
};

fn getFuncModifiers(
    sdk_file: *SdkFile,
    config_name: StringPool.Val,
    params: []const metadata.Param,
) ParamModifierSet {
    var set = ParamModifierSet{};
    if (sdk_file.extra_funcs.get(config_name)) |extra_func| {
        sdk_file.extra_funcs_applied.put(config_name, {}) catch |e| oom(e);
        set.ret = extra_func.ret orelse .{};
        var it = extra_func.params.iterator();
        while (it.next()) |entry| {
            const name = entry.key_ptr.*;
            if (std.mem.eql(u8, name.slice, "Return")) @panic("todo");

            const index = findParam(params, name.slice) orelse std.debug.panic(
                "function '{s}' from extra.txt does not have a parameter named '{s}'",
                .{ config_name, name },
            );
            set.params[index] = entry.value_ptr.*;
        }
    }
    return set;
}

fn generateFunction(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    func: Function,
) !void {
    const arches = func.Architectures();
    const return_type = func.ReturnType();
    const return_attrs = func.ReturnAttrs();
    const attrs = func.Attrs();
    const params = func.Params();

    switch (func) {
        .dll => |dll| sdk_file.func_exports.put(try global_symbol_pool.add(dll.Name), {}) catch |e| oom(e),
        .com => {},
        .ptr => {},
    }

    const modifier_set = getFuncModifiers(sdk_file, func.ConfigName(), params);

    if (arches.filter) |filter| switch (func) {
        .dll => try generateArchPrefix(writer, sdk_file.depth, filter, "pub "),
        .com => @panic("COM methods can be architecture specific?"),
        .ptr => {}, // arch prefix will have already been generated
    };
    defer if (arches.filter) |_| switch (func) {
        .dll => generateArchSuffix(writer),
        .com => @panic("COM methods can be architecture specific?"),
        .ptr => {}, // arch suffix will have already been generated
    };

    if (attrs.SpecialName) {
        try writer.line("// TODO: this function has a \"SpecialName\", should Zig do anything with this?");
    }
    if (attrs.PreserveSig) {
        // we don't care about PreserveSig because we don't automatically turn HRESULT return
        // values into errors
    }
    try generatePlatformComment(writer, func.Platform());
    switch (func) {
        .dll => |dll| if (dll_funcs_with_issues.get(dll.Name)) |_| {
            try writer.linef("// This function from dll '{s}' is being skipped because it has some sort of issue", .{dll.DllImport});
            try writer.linef("pub fn {s}() void {{ @panic(\"this function is not working\"); }}", .{dll.Name});
            return;
        },
        .com => {},
        .ptr => {},
    }

    switch (func) {
        .dll => |dll| {
            // we modify the dll_import to be lowercase because zig generates
            // the .lib files using lowercase since that's what mingw uses.
            // note the casing only matters on case-sensitive filesystems
            try writer.linef(
                "pub extern \"{s}\" fn {}(",
                .{ fmtLower(dll.DllImport, 100), std.zig.fmtId(dll.Name) },
            );
        },
        .com => |com| {
            try writer.linef("{}: *const fn(", .{std.zig.fmtId(com.zig_name)});
            try writer.linef("    self: *const {s},", .{com.type_name});
        },
        .ptr => |ptr| try writer.linef("{s}*const fn(", .{ptr.def_prefix}),
    }

    try generateParams(sdk_file, writer, arches, modifier_set, params);

    try writer.writef(") callconv(@import(\"std\").os.windows.WINAPI) ", .{}, .{ .nl = false });
    if (attrs.DoesNotReturn) {
        try writer.write("noreturn", .{ .start = .mid, .nl = false });
    } else {
        // TODO: set is_const, in and out properly
        const return_opts = TypeRefFormatter.Options.fromParamAttrs(return_attrs, .var_decl, modifier_set.ret);
        const return_type_formatter = try addTypeRefs(sdk_file, arches, return_type, return_opts, null);
        try generateTypeRef(sdk_file, writer, return_type_formatter);
    }
    const term = switch (func) {
        .dll => ";",
        .com => ",",
        .ptr => |ptr| ptr.def_suffix,
    };
    try writer.writef("{s}", .{term}, .{ .start = .mid });
}

fn generateParams(
    sdk_file: *SdkFile,
    writer: *CodeWriter,
    arches: metadata.Architectures,
    modifier_set: ParamModifierSet,
    params: []const metadata.Param,
) !void {
    for (params, 0..) |*param, i| {
        const modifiers = modifier_set.params[i];
        const param_options = TypeRefFormatter.Options.fromParamAttrs(param.Attrs, .var_decl, modifiers);
        const param_type_formatter = try addTypeRefs(sdk_file, arches, param.Type, param_options, null);
        if (param_options.optional_bytes_param_index) |bytes_param_index| {
            try writer.linef("    // TODO: what to do with BytesParamIndex {}?", .{bytes_param_index});
        }
        try writer.writef("    {p}: ", .{std.zig.fmtId(param.Name)}, .{ .nl = false });
        try generateTypeRef(sdk_file, writer, param_type_formatter);
        try writer.write(",", .{ .start = .mid });
    }
}

fn generateUnicodeAliases(sdk_file: *SdkFile, writer: *CodeWriter, unicode_aliases: []const []const u8) !void {
    try writer.line("const thismodule = @This();");
    try writer.linef("pub usingnamespace switch (@import(\"{s}zig.zig\").unicode_mode) {{", .{sdk_file.getWin32DirImportPrefix()});
    try writer.line("    .ansi => struct {");
    for (unicode_aliases) |alias| {
        try writer.linef("        pub const {s} = thismodule.{0s}A;", .{alias});
    }
    try writer.line("    },");
    try writer.line("    .wide => struct {");
    for (unicode_aliases) |alias| {
        try writer.linef("        pub const {s} = thismodule.{0s}W;", .{alias});
    }
    try writer.line("    },");
    try writer.line("    .unspecified => if (@import(\"builtin\").is_test) struct {");
    for (unicode_aliases) |alias| {
        try writer.linef("        pub const {s} = *opaque{{}};", .{alias});
    }
    try writer.line("    } else struct {");
    for (unicode_aliases) |alias| {
        try writer.linef("        pub const {s} = @compileError(\"'{0s}' requires that UNICODE be set to true or false in the root module\");", .{alias});
    }
    try writer.line("    },");
    try writer.line("};");
}

pub fn formatArchesCase(filter: metadata.Architectures.Filter, buf: []u8) !usize {
    var fbs = std.io.fixedBufferStream(buf);
    const arch_writer = fbs.writer();
    var case_prefix: []const u8 = "";
    inline for (std.meta.fields(metadata.Architectures.Filter)) |arch_field| {
        const enabled = @field(filter, arch_field.name);
        if (enabled) {
            try arch_writer.print("{s}.{s}", .{ case_prefix, arch_field.name });
            case_prefix = ", ";
        }
    }
    try arch_writer.writeAll(" => ");
    return fbs.pos;
}

const ArchCount = 3;
fn ArchSpecificObject(comptime T: type) type {
    return struct {
        filter: metadata.Architectures.Filter,
        obj: T,
    };
}
fn ArchSpecificObjects(comptime T: type) type {
    return struct {
        object_array: [ArchCount]ArchSpecificObject(T) = undefined,
        object_count: u8 = 0,
        pub fn getItems(self: *@This()) []ArchSpecificObject(T) {
            return self.object_array[0..self.object_count];
        }
        pub fn getItemsConst(self: *const @This()) []const ArchSpecificObject(T) {
            return self.object_array[0..self.object_count];
        }
        pub fn add(self: *@This(), obj: ArchSpecificObject(T)) void {
            std.debug.assert(self.object_count < self.object_array.len);
            self.object_array[self.object_count] = obj;
            self.object_count += 1;
        }
    };
}

pub fn jsonObjEnforceKnownFieldsOnly(
    map: std.json.ObjectMap,
    known_fields: []const []const u8,
    sdk_file: *const SdkFile,
) !void {
    var it = map.iterator();
    fieldLoop: while (it.next()) |kv| {
        for (known_fields) |known_field| {
            if (std.mem.eql(u8, known_field, kv.key_ptr.*))
                continue :fieldLoop;
        }
        std.log.err(
            "{s}: JSON object has unknown field '{s}', expected one of: {}\n",
            .{ sdk_file.json_basename, kv.key_ptr.*, common.formatSliceT([]const u8, "s", known_fields) },
        );
        jsonPanic();
    }
}

pub fn jsonObjGetRequired(
    map: std.json.ObjectMap,
    field: []const u8,
    sdk_file: *const SdkFile,
) !std.json.Value {
    return map.get(field) orelse {
        // TODO: print file location?
        std.log.err("{s}: json object is missing '{s}' field: {}\n", .{ sdk_file.json_basename, field, fmtJson(map) });
        jsonPanic();
    };
}

// TODO: this should probably be in std.json
pub fn jsonEql(a: std.json.Value, b: std.json.Value) bool {
    switch (a) {
        .integer => |a_val| switch (b) {
            .integer => |b_val| return a_val == b_val,
            else => return false,
        },
        .number_string => |a_val| switch (b) {
            .number_string => |b_val| return std.mem.eql(u8, a_val, b_val),
            else => return false,
        },
        else => @panic("not impl"),
    }
}

fn getMethodConflictMap(json_name: []const u8) std.StaticStringMap(void) {
    if (std.mem.eql(u8, json_name, "Media.MediaPlayer")) return std.StaticStringMap(void).initComptime(.{
        .{"Guid"}, // conflicts with an imported type
    });
    return std.StaticStringMap(void).initComptime(.{});
}

// NOTE: this data could be generated automatically by doing a first pass
fn getParamConflictMap(json_name: []const u8) std.StaticStringMap(void) {
    @setEvalBranchQuota(9999);
    if (std.mem.eql(u8, json_name, "System.Mmc")) return std.StaticStringMap(void).initComptime(.{
        .{"Node"},
        .{"Nodes"},
        .{"Frame"},
        .{"Column"},
        .{"Columns"},
        .{"ScopeNamespace"},
        .{"SnapIn"},
        .{"Extension"},
        .{"View"},
        .{"Document"},
        .{"MenuItem"},
        .{"Views"},
        .{"SnapIns"},
        .{"Property"},
        .{"Properties"},
        .{"Extensions"},
        .{"ContextMenu"},
        .{"Guid"},
        .{"IsScopeNode"},
        .{"Enable"},
        .{"Name"},
        .{"IsSortColumn"},
        .{"IsSelected"},
    });
    if (std.mem.eql(u8, json_name, "System.SettingsManagementInfrastructure")) return std.StaticStringMap(void).initComptime(.{
        .{"Attributes"},
        .{"Children"},
        .{"Settings"},
    });
    if (std.mem.eql(u8, json_name, "UI.TabletPC")) return std.StaticStringMap(void).initComptime(.{
        .{"EventMask"},
        .{"InkDisplayMode"},
        .{"Guid"},
        .{"Item"},
        .{"DoesPropertyExist"},
        .{"Transform"},
        .{"ToString"},
        .{"CanPaste"},
        .{"AlternatesFromSelection"},
        .{"GetStrokesFromStrokeRanges"},
        .{"GetStrokesFromTextRange"},
        .{"AlternatesWithConstantPropertyValues"},
        .{"GetStrokesFromStrokeRanges"},
        .{"GetStrokesFromTextRange"},
        .{"AlternatesWithConstantPropertyValues"},
        .{"RemoveWord"},
    });
    if (std.mem.eql(u8, json_name, "UI.Shell")) return std.StaticStringMap(void).initComptime(.{
        .{"Folder"},
    });
    if (std.mem.eql(u8, json_name, "Media.DirectShow")) return std.StaticStringMap(void).initComptime(.{
        .{"Quality"},
        .{"ScanModulationTypes"},
        .{"AnalogVideoStandard"},
        .{"Guid"},
        .{"HideCursor"},
        .{"UseScanLine"},
        .{"UseOverlayStretch"},
        .{"UseWhenFullScreen"},
        .{"UseScanLine"},
        .{"UseWhenFullScreen"},
    });
    if (std.mem.eql(u8, json_name, "Media.Speech")) return std.StaticStringMap(void).initComptime(.{
        .{"Guid"},
        .{"Alternates"},
    });
    if (std.mem.eql(u8, json_name, "Media.MediaFoundation")) return std.StaticStringMap(void).initComptime(.{
        .{"Guid"},
    });
    if (std.mem.eql(u8, json_name, "System.Diagnostics.Debug")) return std.StaticStringMap(void).initComptime(.{
        .{"Guid"},
        .{"Symbol"},
        .{"Request"},
        .{"Exception"},
    });
    if (std.mem.eql(u8, json_name, "System.RemoteDesktop")) return std.StaticStringMap(void).initComptime(.{
        .{"DisplayIOCtl"},
    });
    if (std.mem.eql(u8, json_name, "System.Performance")) return std.StaticStringMap(void).initComptime(.{
        .{"Stop"},
    });
    if (std.mem.eql(u8, json_name, "Web.MsHtml")) return std.StaticStringMap(void).initComptime(.{
        .{"item"},
        .{"Gravity"},
    });
    if (std.mem.eql(u8, json_name, "Data.Xml.MsXml")) return std.StaticStringMap(void).initComptime(.{
        .{"hasFeature"},
    });
    if (std.mem.eql(u8, json_name, "UI.Controls.RichEdit")) return std.StaticStringMap(void).initComptime(.{
        .{"Notify"},
    });
    if (std.mem.eql(u8, json_name, "Devices.ImageAcquisition")) return std.StaticStringMap(void).initComptime(.{
        .{"hResult"},
    });
    return std.StaticStringMap(void).initComptime(.{});
}

pub const FmtId = struct {
    s: []const u8,
    kind: enum { param, com_method },
    avoid_map: std.StaticStringMap(void),
    pub fn format(
        self: @This(),
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        _ = fmt;
        _ = options;
        if (self.avoid_map.get(self.s)) |_| {
            const prefix: []const u8 = switch (self.kind) {
                .param => "_param_",
                .com_method => "_method_",
            };
            try writer.print("{s}{s}", .{ prefix, self.s });
        } else {
            try writer.print("{}", .{std.zig.fmtId(self.s)});
        }
    }
};

fn FmtOptOrEmpty(comptime T: type) type {
    return struct {
        opt: T,
        pub fn format(
            self: @This(),
            comptime fmt: []const u8,
            options: std.fmt.FormatOptions,
            writer: anytype,
        ) !void {
            _ = options;
            if (self.opt) |v| {
                try writer.print(fmt, .{v});
            }
        }
    };
}
pub fn fmtOptOrEmpty(opt: anytype) FmtOptOrEmpty(@TypeOf(opt)) {
    return .{ .opt = opt };
}

pub fn fmtParamId(s: []const u8, avoid_map: std.StaticStringMap(void)) FmtId {
    return FmtId{ .s = s, .kind = .param, .avoid_map = avoid_map };
}
pub fn fmtComMethodId(s: []const u8, avoid_map: std.StaticStringMap(void)) FmtId {
    return FmtId{ .s = s, .kind = .com_method, .avoid_map = avoid_map };
}

pub fn FmtLower(comptime buffer_size: comptime_int) type {
    return struct {
        s: []const u8,
        pub fn format(
            self: @This(),
            comptime fmt: []const u8,
            options: std.fmt.FormatOptions,
            writer: anytype,
        ) !void {
            _ = fmt;
            _ = options;
            var buffered = std.io.BufferedWriter(buffer_size, @TypeOf(writer)){ .unbuffered_writer = writer };
            for (self.s) |c| {
                const lower = [_]u8{std.ascii.toLower(c)};
                try buffered.writer().writeAll(&lower);
            }
            try buffered.flush();
        }
    };
}
pub fn fmtLower(s: []const u8, comptime buffer_size: comptime_int) FmtLower(buffer_size) {
    return .{ .s = s };
}

fn withoutCrLen(s: []const u8) usize {
    @setEvalBranchQuota(3000);
    return s.len - std.mem.count(u8, s, "\r");
}

fn removeCr(comptime s: []const u8) [withoutCrLen(s):0]u8 {
    comptime {
        const len = withoutCrLen(s);
        var without_cr: [len:0]u8 = undefined;
        var i: usize = 0;
        for (s) |e| {
            if (e != '\r') {
                without_cr[i] = e;
                i += 1;
            }
        }
        std.debug.assert(i == len);
        return without_cr;
    }
}

fn cleanDir(dir: std.fs.Dir, sub_path: []const u8) !void {
    std.log.info("cleandir '{s}'", .{sub_path});
    try dir.deleteTree(sub_path);
    const MAX_ATTEMPTS = 30;
    var attempt: u32 = 1;
    while (true) : (attempt += 1) {
        if (attempt > MAX_ATTEMPTS)
            fatal("failed to delete '{s}' after {} attempts", .{ sub_path, MAX_ATTEMPTS });

        // ERROR: windows.OpenFile is not handling error.Unexpected NTSTATUS=0xc0000056
        dir.makeDir(sub_path) catch |e| switch (e) {
            else => {
                std.debug.print("[DEBUG] makedir failed with {}\n", .{e});
                //std.process.exit(0xff);
                continue;
            },
        };
        break;
    }
}
